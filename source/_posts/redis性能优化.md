---
title: Redis性能优化
date: 2021-04-02 18:08:38
categories: [Redis]
tags: [Redis, 优化, 调优, 性能]
---

Redis在高并发场景下对于性能要求较高，总结一下常用的Redis性能调优方案。

<!--more-->

### 优化方式

1. 缩短键值对的存储长度
2. 使用lazy free（延迟删除）特性
3. 设置键值的过期时间
4. 禁用长耗时的查询命令
5. 使用slowlog优化耗时命令
6. 使用pipline批量操作数据
7. 避免大量数据同时失效
8. 客户端使用优化
9. 限制redis内存大小
10. 使用物理机而非虚拟机安装Redis服务
11. 检查数据持久化策略
12. 禁用THP特性
13. 使用分布式架构增加读写速度

### 优化方案解析

#### 1.缩短键值对的存储产长度

Redis对于同一种数据类型会使用不同的内部编码进行存储，通过不同编码实现效率和空间的平衡，然而数据量越大，使用的内部编码就会越复杂，越是复杂的内部编码，存储的性能就会越低。

当键值对较大时，还会带来另外的问题：

- 内容越大，需要持久化的时间就会越长，需要挂起的时间越长，Redis的性能越低。
- 内容越大，网络上传输的内容越多，传输时间变长，整体运行速度降低。
- 内容大，内存占用变大，会频繁触发内存淘汰机制，给Redis带来更多的运行负担。

所以，在保证完整语义的情况下，尽量缩短键值对的存储长度，必要时对数据进行序列化和压缩，然后在存储。

#### 2.使用lazy free特性

lazy free是Redis 4.0新增的功能，意思为惰性删除、延迟删除，在删除的时候提供异步延时释放键值的功能，把键值释放操作放在BIO（Background I/O）单独的子线程中处理，减少删除对主线程的阻塞，可以有效避免删除big key时带来的性能和可用性问题。

四种场景：

- lazyfree-lazy-eviction：当Redis运行内存超过maxmemory时，是否开启lazy free机制删除。
- lazyfree-lazy-expire：表示设置了过期时间的键值，过期之后是否开启lazy free机制删除。
- lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个隐式的del键操作，例如rename命令，当目标键已经存在，Redis会先删除目标键，如果这些目标键是big key就会造成阻塞删除的问题。
- lazyfree-lazy-flush：针对 slave 从节点进行全量数据同步，slave在加载 master 的RDB文件前，会会运行flushall来清理自己的数据。

#### 3.设置键值的过期时间

根据实际业务情况，设置键值的合理过期时间，Redis会自动清除过期的键值对，节约内存占用，避免键值对过多的堆积，频发触发淘汰策略。

#### 4.禁用长耗时的查询命令

Redis只用一个线程来做数据查询，如果查询指令时间比较长，就会阻塞Redis，造成延时。

避免O(n)命令对于Redis造成影响，可以有的优化方式:

- 禁止使用keys命令
- 避免一次查询所有成员，使用scan命令进行分批的、游标式的遍历
- 通过机制严格控制Hash、Set、Sorted Set等数据结构的大小
- 将排序、并集、交集等操作放在客户端执行，减少Redis服务器压力
- 删除一个大数据的时候，可能会需要较长时间，建议用异步删除的方式unlink，会启动一个新的线程来删除目标数据，不阻塞主线程

#### 5.使用slowlog优化查询耗时

使用slowlog功能找出最耗时的Redis命令进行优化，提高运行速度。

- `slowlog-log-slower-than`：用于设置慢查询的评定时间，超过此配置项的命令，会被当成慢操作记录在慢查询日志中，执行单位为微妙。
- `slowlog-max-len`：配置慢查询日志的最大记录数

#### 6.使用pipline批量操作数据

Pipline-管道技术是客户端提供的一种批处理技术，用于一次处理多个Redis命令，从而提高整个交互的性能。

#### 7.避免大量数据同时失效

Redis过期键值删除使用的是贪心策略，每秒会进行十次过期扫描，这个扫描频率可以在redia.conf中进程配置，默认值是`hz 10`，Redis会随机抽取20个值，删除这20个键中过期的键，如果过去key的比例超过25%，会重复执行扫描-选取-删除的过程。

如果在大型系统中有大量缓存在同一时间同时过期，那么Redis会循环多次进行扫描删除操作，直到过期键值被删除的比较稀疏位置，整个删除过程中会导致Redis的读写产生明显卡顿，同时卡顿的另一种原是内存页管理器会频繁回收内存页，因此也会消耗一定的CPU。

为了避免卡顿现象的发生，设计过程中需要预防大量的缓存在同一时刻一起过期，最简单的设计方案就是在过期时间的基础上添加一个指定范围的随机数。

#### 8.客户端使用优化

在客户端使用时除了尽量使用Pipline以外，还要注意使用Redis连接池，而不是频繁创建销毁Redis连接，这样可以减少网络传输次数和非必要调用指令。

#### 9.限制Redis内存大小

64位操作系统没有限制Redis的内存大小，配置项`maxmemory<bytes>`是被注释掉的，这样就会导致在物理内存不足时，使用swap交换空间，操作系统将Redis使用的内存分页迁移到swap的时候，会阻塞Redis进程，Redis会出现延迟，影响整体性能。因此需要设置一个固定的Redis内存大小，当Redis的运行内存达到这个值的时候会触发内存淘汰策略。

Redis 4.0以后内存淘汰策略有8种：

1. `noeviction`：不淘汰任何数据，内存不足时，新增操作会报错，这个是默认的淘汰策略。
2. `allkeys-lru`：淘汰所有键值中最久未使用的键值
3. `allkeys-random`：随机淘汰任意键值
4. `volatile-lru`：淘汰所有设置了过期时间的键值中最久未使用的键值
5. `volatile-random`：随机淘汰设置了过期时间的任意键值
6. `volatile-ttl`：优先淘汰更早过期的键值
7. `volatile-lfu`：淘汰所有设置过期时间的键值中，最少使用的键值
8. `allkeys-lfu`：淘汰所有键值中使用最少的键值

#### 10.使用物理机而非虚拟机

#### 11.检查数据持久化策略

Redis的持久化策略是将内存数据复制到硬盘上，这样才能进行容灾恢复或者数据迁移，但是维护持久化的功能，需要很大的性能开销。

持久化方式：

- RDB（Redis Database，快照方式）将某一个时刻的内存数据以二进制的方式写入磁盘。
- AOF（Append Only File，文件追加方式）记录所有的操作命令，并以文本的形式追加到文件中。
- 混合持久化方式，Redis 4.0以后版本支持。写入的时候，先把当前的数据以RDB的形式写入文件的开头，再将后续的操作命令以AOF的格式写入文件，既能保证Redis重启时的速度，又能降低数据丢失的风险。

RDB可能会导致一定时间内的数据丢失，AOF文件较大的话则会影响Redis启动速度，混合持久化方式则结合了两种方式的优点。

#### 12.禁用THP特性

Linux kernel在 2.6.38内核增加了Transparent Huge Pages（THP）特性，支持大内存页2MB分配。

开启THP的时候，fork速度会变慢，fork之后，每个内存页从4KB变成2MB，会大幅增加重写期间父进程内存消耗。每次写命令引起的复制内存页单位放大了512倍，会拖慢写操作的执行时间，导致大量写操作慢查询。

#### 13.使用分布式架构增加读写速度

Redis分布式架构的三个重要手段：

- 主从同步
- 哨兵模式
- Redis Cluster集群

主从同步把写操作放到主库上执行，读操作放到从服务上，从而在单位时间内处理更多请求，提升性能

哨兵模式主要针对主从功能的升级，当主节点崩溃以后，无需人工干预，能够自动恢复Redis的使用

Redis Cluster集群通过将数据库分散存储到多个节点，平衡各个节点的负载压力。

> Redis Cluster 采用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：slot = CRC16(key) & 16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。这样 Redis 就可以把读写压力从一台服务器，分散给多台服务器了，因此性能会有很大的提升。