---
title: 常见设计模式
date: 2021-04-02 18:05:40
categories: [设计模式]
tags: [设计模式, 程序员的修炼]
---

## 设计模式

### 单例模式

- 单例模式相关概念
  
  <!--more-->
  
  - 确保一个类最大只有一个实例，提供全局唯一一个访问点。
  - 懒汉式单例模式，加载时不初始化，获取调用时初始化。
  - 饿汉式单例模式，加载时完成初始化，类加载比较慢，获取对象的速度快。

#### 饿汉式单例模式

- 线程安全

- 实现

  ```java
  public class Singleton {
      private static Singleton singleton = new Singleton();
  
      private Singleton() {
      }
      public static Singleton getInstance() {
          return singleton;
      }
      public void sayHi() {
          System.out.println("hi~~~~~~~~~");
      }
  }
  //调用
  Singleton.getInstance().sayHi();
  ```

#### 双检锁单例模式

- 线程安全

- 实现

  ```java
  public class Singleton {
      private static Singleton singleton = null;
      public Singleton() {
      }
      public static Singleton getInstance() {
          if(singleton == null){
              synchronized (Singleton.class){
                  if(singleton == null){
                      singleton = new Singleton();
                  }
              }
          }
          return singleton;
      }
      public void sayHi() {
          System.out.println("hi~~~~~~~~~");
      }
  }
  //调用
  Singleton.getInstance().sayHi();
  ```

#### 静态内部类单例模式

- 线程安全

- 实现

  ```java
  public class Singleton {
      private static class SingletonHolder {
          public static Singleton singleton = new Singleton();
      }
  
      public static Singleton getInstance() {
          return SingletonHolder.singleton;
      }
  
      public Singleton() {
      }
  
      public void sayHi() {
          System.out.println("hi~~~~~~~~~");
      }
  }
  ```

#### 静态代码块

- 线程安全

- 实现

  ```java
  public class Singleton {
      public Singleton() {
      }
  
      private static Singleton singleton = null;
  
      static {
          singleton = new Singleton();
      }
  
      public static Singleton getSingleton() {
          return singleton;
      }
  
      public void sayHi() {
          System.out.println("hi~~~~~~~~~");
      }
  }
  ```

  **使用评价：花里胡哨，不实用，没达到lazyloading的目的，写法花哨，不推荐**

### 代理模式

- 定义：给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用。

- 优势：在不改变目标对象方法的情况下对方法增强。

- 实现

  创建一个用户接口（UserInterface）

  ```java
  public interface UserInterface {
      void service(String s);
  }
  ```

  创建对应的用户实现类（UserImpl）

  ```java
  public class UserImpl implements UserInterface {
      @Override
      public void service(String s) {
          System.out.println("I'am " + s);
      }
  }
  ```

  创建代理类对象（UserProxy），通过代理类创建实现类的实例，并提供访问

  ```java
  public class UserProxy implements UserInterface {
      private UserInterface user;
  
      public UserProxy(UserInterface user) {
          this.user = user;
      }
  
      @Override
      public void service(String s) {
          System.out.println("check identity");
          user.service(s);
          System.out.println("check in");
      }
  }
  ```

  在使用时通过proxy调用

  ```java
  public class Test {
      public static void main(String[] args) {
          UserImpl user = new UserImpl();
          UserProxy proxy = new UserProxy(user);
          proxy.service("wpt");
      }
  }
  ```

### 观察者模式

- 定义：对象之间的一对多依赖，当一个状态改变时，它的所有依赖着都会收到通知并自动更新。Subject时被观察的对象，而其所有依赖者Observer被称为观察者。

- 原则：为了交互对象之间的松耦合设计，两个对象松耦合，但是可以交互，并不清楚彼此的细节。松耦合的两个对象之间，相互依赖程度低，系统具有弹性，能够应对变化。

- 实例

  被观察者Subject接口

  ```java
  public interface Subject {
      public void registerObserver(Observer observer);
      public void removeObserver(Observer observer);
      public void notifyObserver();
  }
  ```

  观察者接口

  ```java
  public interface Observer {
      public void update(String message);
  }
  ```

  被观察者实例

  ```java
  public class ConcreteSubject implements Subject {
      private List<Observer> list;
      private String message;
  
      public ConcreteSubject() {
          list = new ArrayList<Observer>();
      }
      @Override
      public void registerObserver(Observer observer) {
          list.add(observer);
      }
      @Override
      public void removeObserver(Observer observer) {
          if(!list.isEmpty()){
              list.remove(observer);
          }
      }
      @Override
      public void notifyObserver() {
          for (Observer observer :
                  list) {
              observer.update(message);
          }
      }
      public void send(String s){
          this.message = s;
          System.out.println("update message: "+s);
          notifyObserver();
      }
  }
  ```

  定义观察者类，实现具体方法

  ```java
  public class ConcreteObserver implements Observer {
      private String name;
      private String message;
  
      public ConcreteObserver(String name) {
          this.name = name;
      }
      @Override
      public void update(String message) {
          this.message = message;
          read();
      }
      private void read() {
          System.out.println(name + " get message: " + message);
      }
  }
  ```

  测试添加和移除观察者前后收到信息通知的过程

  ```java
  public class ObserverTest {
      public static void main(String[] args) {
          ConcreteSubject subject = new ConcreteSubject();
  
          Observer observer = new ConcreteObserver("zhangsan");
          Observer observer1 = new ConcreteObserver("lisi");
          Observer observer2 = new ConcreteObserver("wangwu");
  
          subject.registerObserver(observer);
          subject.registerObserver(observer1);
          subject.registerObserver(observer2);
          subject.send("hello, i am here");
  
          subject.removeObserver(observer);
          subject.send("byebye");
      }
  }
  ```

### 简单工厂模式

- 优点：
  - 将创建实例的工作与使用实例的工作分开，使用者无需关心类对象是如何创建的，明确职责。
  - 初始化实例的工作放在工厂类里面进行，代码容易维护，更符合面向对象的原则，面向接口编程，而不是面向实现编程。
- 缺点：
  - 工厂类里面包含了所有的产品创建逻辑，如果出现异常，整个系统都会受影响。
  - 新增产品类的时候就要修改工厂类的代码，与开闭原则不符。
  - 简单工厂模式中使用了静态工厂方法，导致工厂角色无法形成基于继承的等级结构。

### 工厂模式

- 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到子类。

- 优点

  - 更符合开闭原则，新增一种产品，只需要添加相应的具体产品类和对应的工厂子类。
  - 符合单一职责原则，每个具体的工厂类，只负责创建对应的产品
  - 不使用静态工厂方法，可以形成基于继承的等级结构。

- 缺点

  添加新的产品的时候，除了增加新产品类以外，还要提供具体的与之对应的工厂类，系统中类的个数成对增加，在一定程度上增加了系统的复杂性，同时更多的类需要编译和运行，增加额外开销。

  虽然保证了工厂方法内的对修改关闭，但是对于使用工厂方法的类，如果要更换另一种产品，仍需要修改实例化的具体工厂类。

  一个工厂只能创建一种具体产品。

### 抽象工厂模式

- 提供一个接口，用于创建相关或者依赖对象的家族，不需要明确指定具体类。
- 优点
  - 抽象工厂模式隔离了具体类的生产，客户端无需知道具体内容的创建。
  - 一个产品族中的多个对象被设计成一起工作，能保证客户端始终使用同一个产品族中的对象。
  - 增加新的具体工厂和产品族很方便，无需修改已有系统，符合开闭原则。
- 缺点
  - 增加新产品的等级结构复杂，需要修改抽象工厂和所有的具体工厂类，对开闭原则的支持呈现倾斜性。