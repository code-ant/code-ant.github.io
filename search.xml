<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>在OS X上配置JAVA_HOME环境变量</title>
    <url>/2020/09/13/config-java-home-on-mac/</url>
    <content><![CDATA[<p>在Mac上配置Java开发环境的时候，遇到了一些问题，搜索一番下来之后，更困惑了，各类教程基本上是复制粘贴，而且还很老旧，或者按照Linux系列的系统进行配置，部分情况下配置无法生效，特意搜了一下官方文档，总结一下最新的配置方法。</p>
<a id="more"></a>

<p><strong>系统环境</strong></p>
<p>系统版本：macOS Catalina 10.15.6</p>
<p>Shell：zsh</p>
<p><a href="https://developer.apple.com/library/archive/qa/qa1170/_index.html" target="_blank" rel="noopener">官方链接</a></p>
<blockquote>
<p>Many Java applications need to know the location of a <code>$JAVA_HOME</code> directory. The <code>$JAVA_HOME</code> on Mac OS X should be found using the <code>/usr/libexec/java_home</code> command line tool on Mac OS X 10.5 or later. On older Mac OS X versions where the tool does not exist, use the fixed path “<code>/Library/Java/Home</code>“. The <code>/usr/libexec/java_home</code> tool dynamically finds the top Java version specified in Java Preferences for the current user. This path allows access to the <code>bin</code> subdirectory where command line tools such as <code>java</code>, <code>javac</code>, etc. exist as on other platforms. The tool <code>/usr/libexec/java_home</code> allows you to specify a particular CPU architecture and Java platform version when locating a <code>$JAVA_HOME</code>.</p>
<p>Another advantage of dynamically finding this path, as opposed to hardcoding the fixed endpoint, is that it is updated when a new version of Java is downloaded via Software Update or installed with a newer version of Mac OS X. For this reason, it is important that developers do not install files in the JDKs inside of <code>/System</code>, since the changes will be lost with subsequent updates by newer versions of Java.</p>
<p>To obtain the path to the currently executing <code>$JAVA_HOME</code>, use the <code>java.home</code> System property.</p>
</blockquote>
<p><strong>developer.apple.com中明确指出了，10.5以后的系统版本使用<code>/usr/libexec/java_home</code>进行配置。</strong></p>
<p>看一下<code>/usr/libexec/java_home</code>究竟是个什么东西</p>
<p><img src="http://images.wpt6.cn/blog/2020-09-13-23-57-38.png" alt="2020-09-13-23-57-38"></p>
<p><strong>为什么要使用/ usr / libexec / java_home？</strong><br>此<code>java_home</code>可以返回在Java首选项中为当前用户指定的Java版本。</p>
<p>例如：</p>
<p><img src="http://images.wpt6.cn/blog/2020-09-14-00-05-42.png" alt="2020-09-14-00-05-42"></p>
<p>通过-V查看当前安装的所有Java的版本</p>
<p>可以使用java_home -v &lt;JDK版本号&gt;来进行切换</p>
<p>参考：<a href="https://www.jianshu.com/p/af79ae7f732c" target="_blank" rel="noopener">在 Mac OS 上管理多个 jdk 版本</a></p>
<hr>
<p>除去上面配置Java_HOME的一点，还有zsh和shell的区别，众多教程里面也没有注明，不加分辨，盲目复制会走不少弯路。</p>
<p>重要原因在于：macOS Catalina 默认的shell环境是zsh，zsh和shell的加载配置文件是不一样的，按照习惯，在<code>/etc/profile</code>或者<code>～/.bashrc</code>中添加环境变量信息会不起作用。</p>
<p>看一下<code>man zsh</code>的说明</p>
<blockquote>
<p><strong>STARTUP/SHUTDOWN</strong> <strong>FILES</strong></p>
<p>​    Commands are first read from <strong>/etc/zshenv</strong>; this cannot be overridden. Subsequent be-</p>
<p>​    haviour is modified by the <strong>RCS</strong> and <strong>GLOBAL_RCS</strong> options; the former affects all startup</p>
<p>​    files, while the second only affects global startup files (those shown here with an</p>
<p>​    path starting with a <strong>/</strong>). If one of the options is unset at any point, any subsequent</p>
<p>​    startup file(s) of the corresponding type will not be read. It is also possible for a</p>
<p>​    file in <strong>$ZDOTDIR</strong> to re-enable <strong>GLOBAL_RCS</strong>. Both <strong>RCS</strong> and <strong>GLOBAL_RCS</strong> are set by default.</p>
<p>​    Commands are then read from <strong>$ZDOTDIR/.zshenv</strong>. If the shell is a login shell, commands</p>
<p>​    are read from <strong>/etc/zprofile</strong> and then <strong>$ZDOTDIR/.zprofile</strong>. Then, if the shell is inter-</p>
<p>​    active, commands are read from <strong>/etc/zshrc</strong> and then <strong>$ZDOTDIR/.zshrc</strong>. Finally, if the</p>
<p>​    shell is a login shell, <strong>/etc/zlogin</strong> and <strong>$ZDOTDIR/.zlogin</strong> are read.</p>
<p>​    When a login shell exits, the files <strong>$ZDOTDIR/.zlogout</strong> and then <strong>/etc/zlogout</strong> are read.</p>
<p>​    This happens with either an explicit exit via the <strong>exit</strong> or <strong>logout</strong> commands, or an</p>
<p>​    implicit exit by reading end-of-file from the terminal. However, if the shell termi-</p>
<p>​    nates due to <strong>exec</strong>‘ing another process, the logout files are not read. These are also</p>
<p>​    affected by the <strong>RCS</strong> and <strong>GLOBAL_RCS</strong> options. Note also that the <strong>RCS</strong> option affects the</p>
<p>​    saving of history files, i.e. if <strong>RCS</strong> is unset when the shell exits, no history file</p>
<p>​    will be saved.</p>
<p>​    If <strong>ZDOTDIR</strong> is unset, <strong>HOME</strong> is used instead. Files listed above as being in <strong>/etc</strong> may be</p>
<p>​    in another directory, depending on the installation.</p>
<p>​    As <strong>/etc/zshenv</strong> is run for all instances of zsh, it is important that it be kept as</p>
<p>​    small as possible. In particular, it is a good idea to put code that does not need to</p>
<p>​    be run for every single shell behind a test of the form `<strong>if</strong> <strong>[[</strong> <strong>-o</strong> <strong>rcs</strong> <strong>]];</strong> <strong>then</strong> <strong>…</strong>‘ so</p>
<p>​    that it will not be executed when zsh is invoked with the `<strong>-f</strong>‘ option.</p>
<p>​    Any of these files may be pre-compiled with the <strong>zcompile</strong> builtin command (see zsh-</p>
<p>​    builtins(1)).  If a compiled file exists (named for the original file plus the <strong>.zwc</strong></p>
<p>​    extension) and it is newer than the original file, the compiled file will be used</p>
<p>​    instead.</p>
<p><strong>FILES</strong></p>
<p>​    <strong>$ZDOTDIR/.zshenv</strong></p>
<p>​    <strong>$ZDOTDIR/.zprofile</strong></p>
<p>​    <strong>$ZDOTDIR/.zshrc</strong></p>
<p>​    <strong>$ZDOTDIR/.zlogin</strong></p>
<p>​    <strong>$ZDOTDIR/.zlogout</strong></p>
<p>​    <strong>${TMPPREFIX}*</strong>  (default is /tmp/zsh*)</p>
<p>​    <strong>/etc/zshenv</strong></p>
<p>​    <strong>/etc/zprofile</strong></p>
<p>​    <strong>/etc/zshrc</strong></p>
<p>​    <strong>/etc/zlogin</strong></p>
<p>​    <strong>/etc/zlogout</strong>  (installation-specific - <strong>/etc</strong> is the default)</p>
</blockquote>
<p>zsh使用的是这些配置文件，所以在上面说的两个bash使用的配置文件中添加环境变量，默认是不加载的。</p>
<p>所以</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "export JAVA_HOME=\$(/usr/libexec/java_home)" &gt;&gt; ~/.zshenv</span><br></pre></td></tr></table></figure>

<p>关于进一步详细设置，可以参考<a href="https://qastack.cn/programming/22842743/how-to-set-java-home-environment-variable-on-mac-os-x-10-9" target="_blank" rel="noopener">如何在Mac OS X 10.9上设置JAVA_HOME环境变量？</a></p>
<p>关于zsh的配置文件的比较，可以参考<a href="https://scriptingosx.com/2019/06/moving-to-zsh-part-2-configuration-files/" target="_blank" rel="noopener">Moving to zsh, part 2: Configuration Files</a>和<a href="https://chenyufei.info/blog/2014-03-04/zsh-tmux-osx-set-correct-path/" target="_blank" rel="noopener">zsh+tmux+OS X: 正确地设置 PATH</a>这两篇博客。</p>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>java</tag>
        <tag>OS X</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2020/09/01/sort-algo/</url>
    <content><![CDATA[<p>总结十大经典排序算法，分析稳定性、时间复杂度等内容；</p>
<h3 id="算法相关定义"><a href="#算法相关定义" class="headerlink" title="算法相关定义"></a>算法相关定义</h3><ul>
<li><p>时间复杂度：</p>
<p>在 大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：<strong>算法的渐进时间复杂度</strong>。</p>
<p>常见的时间复杂度量级有：</p>
<a id="more"></a>

<ul>
<li>常数阶O(1)</li>
</ul>
<!--添加时间复杂度的详细计算方法-->

<ul>
<li>对数阶O(logN)</li>
<li>线性阶O(n)</li>
<li>线性对数阶O(nlogN)</li>
<li>平方阶O(n²)</li>
<li>立方阶O(n³)</li>
<li>K次方阶O(n^k)</li>
<li>指数阶(2^n)</li>
</ul>
</li>
<li><p>空间复杂度：</p>
<p>既然时间复杂度不是用来计算程序具体耗时的，那么也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，用 S(n) 来定义。</p>
<p>空间复杂度比较常用的有：O(1)、O(n)、O(n²)</p>
</li>
<li><p>内排序和外排序</p>
<p>根据排序元素所在位置的不同,排序分: 内排序和外排序。</p>
<ul>
<li><p>内排序：指在排序期间数据对象全部存放在内存的排序。</p>
</li>
<li><p>外排序：指在排序期间全部对象太多，不能同时存放在内存中，必须根据排序过程的要求，不断在内，外存间移动的排序。</p>
</li>
</ul>
<p>内排序在排序过程中，所有元素调到内存中进行的排序，内排序是排序的基础。内排序效率用比较次数来衡量。按所用策略不同，内排序又可分为插入排序、选择排序、交换排序、归并排序及基数排序等几大类。在数据量大的情况下，只能分块排序，但块与块间不能保证有序。外排序用读/写外存的次数来衡量其效率。</p>
</li>
<li><p>排序算法的稳定性</p>
<p>  假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，<strong>r<sub>i</sub>=r<sub>j</sub></strong>，且<strong>r<sub>i</sub></strong>在<strong>r<sub>j</sub></strong>之前，而在排序后的序列中，<strong>r<sub>i</sub></strong>仍在<strong>r<sub>j</sub></strong>之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
</li>
</ul>
<h3 id="十大经典排序算法对比"><a href="#十大经典排序算法对比" class="headerlink" title="十大经典排序算法对比"></a>十大经典排序算法对比</h3><p><img src="http://images.wpt6.cn/blog/2020-09-01-00-39-16.jpg" alt=""></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
<li>内排序：Y</li>
</ul>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; array.length-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j]&lt;array[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">                array[j-<span class="number">1</span>]= temp;</span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ul>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
<li>内排序：Y</li>
</ul>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[min];</span><br><span class="line">        array[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
<li>内排序：Y</li>
</ul>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">            array[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
<li>内排序：Y</li>
</ul>
<h5 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h5><p>选择一个增量序列 t<sub>1</sub>，t<sub>2</sub>，……，t<sub>k</sub>，其中 t<sub>i</sub> &gt; t<sub>j</sub>, t<sub>k</sub> = 1；</p>
<p>按增量序列个数 k，对序列进行 k 趟排序；</p>
<p>每趟排序，根据对应的增量 t<sub>i</sub>，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; array.length) &#123;</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(gap);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = array[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; temp) &#123;</span><br><span class="line">                array[j + gap] = array[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap = (<span class="keyword">int</span>) Math.floor(gap / <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(n)</li>
<li>稳定性：稳定</li>
<li>内排序：N</li>
</ul>
<p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<p>递归和迭代相比较，特定场景下，递归方法可能不适用；例如在JavaScript中递归的算法深度会比较深，是语言所不能承受的。递归方法会导致很频繁的自调用。一个长度为n的数组最终会调用mergeSort() <code>2*n-1</code>次，这意味着如果需要排序的数组长度很大会在某些栈小的浏览器上发生栈溢出错误。尽管迭代的归并排序算法比递归实现要慢一些，但它并不会像递归那样受调用栈限制的影响。把递归算法改用迭代实现是实现栈溢出错误的方法之一</p>
<h5 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h5><ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<p><img src="http://images.wpt6.cn/blog/2020-09-01-22-40-46.jpg" alt=""></p>
<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    sort(<span class="number">0</span>, array.length - <span class="number">1</span>, array, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] array, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        sort(left, mid, array, temp);</span><br><span class="line">        sort(mid + <span class="number">1</span>, right, array, temp);</span><br><span class="line">        merge(left, mid, right, array, temp);</span><br><span class="line">        System.out.println(Arrays.toString(temp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] array, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]&lt;=array[j])&#123;</span><br><span class="line">            temp[t] = array[i];</span><br><span class="line">            t++;i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            temp[t] = array[j];</span><br><span class="line">            t++;j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid)&#123;</span><br><span class="line">        temp[t++] = array[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=right)&#123;</span><br><span class="line">        temp[t++] = array[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        array[left++] = temp[t++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(logn)</li>
<li>稳定性：不稳定</li>
<li>内排序：Y</li>
</ul>
<blockquote>
<p><em>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平均期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</em></p>
</blockquote>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Github、npm配置代理</title>
    <url>/2020/08/23/proxy/</url>
    <content><![CDATA[<p>鉴于一些网络环境的问题，有必要收藏一些代理的使用方法。</p>
<p>记录一些代理的配置方法</p>
<a id="more"></a>

<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="Github设置代理"><a href="#Github设置代理" class="headerlink" title="Github设置代理"></a>Github设置代理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 全局</span></span><br><span class="line">git config --global http.proxy 'socks5://username:password@server:port '</span><br><span class="line">git config --global https.proxy 'socks5://username:password@server:port '</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 局部</span></span><br><span class="line">git config --local http.proxy username:password@server:port</span><br></pre></td></tr></table></figure>

<h3 id="只对于github-com"><a href="#只对于github-com" class="headerlink" title="只对于github.com"></a>只对于github.com</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<h3 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.https://github.com.proxy</span><br></pre></td></tr></table></figure>

<h3 id="查询是否使用代理："><a href="#查询是否使用代理：" class="headerlink" title="查询是否使用代理："></a>查询是否使用代理：</h3><ul>
<li>查询全局代理</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy</span><br></pre></td></tr></table></figure>

<ul>
<li>查询局部代理</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --local http.proxy</span><br></pre></td></tr></table></figure>

<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="npm设置代理"><a href="#npm设置代理" class="headerlink" title="npm设置代理"></a>npm设置代理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set proxy http://username:password@server:port </span><br><span class="line">npm confit set https-proxy http://username:password@server:port</span><br></pre></td></tr></table></figure>

<h3 id="npm删除代理"><a href="#npm删除代理" class="headerlink" title="npm删除代理"></a>npm删除代理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config delete proxy</span><br><span class="line">npm config delete https-proxy</span><br></pre></td></tr></table></figure>

<h3 id="如果代理不支持https的话需要修改npm存放package的网站地址。"><a href="#如果代理不支持https的话需要修改npm存放package的网站地址。" class="headerlink" title="如果代理不支持https的话需要修改npm存放package的网站地址。"></a>如果代理不支持https的话需要修改npm存放package的网站地址。</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry "http://registry.npmjs.org/"</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="npm相关配置"><a href="#npm相关配置" class="headerlink" title="npm相关配置"></a>npm相关配置</h3><blockquote>
<p>npm获取配置有6种方式，优先级由高到底。</p>
<ol>
<li>命令行参数。 <code>--proxy http://server:port</code>即将proxy的值设为<code>http://server:port</code>。</li>
<li>环境变量。 以<code>npm_config_</code>为前缀的环境变量将会被认为是npm的配置属性。如设置proxy可以加入这样的环境变量<code>npm_config_proxy=http://server:port</code>。</li>
<li>用户配置文件。可以通过<code>npm config get userconfig</code>查看文件路径。如果是mac系统的话默认路径就是<code>$HOME/.npmrc</code>。</li>
<li>全局配置文件。可以通过<code>npm config get globalconfig</code>查看文件路径。mac系统的默认路径是<code>/usr/local/etc/npmrc</code>。</li>
<li>内置配置文件。安装npm的目录下的npmrc文件。</li>
<li>默认配置。 npm本身有默认配置参数，如果以上5条都没设置，则npm会使用默认配置参数。</li>
</ol>
<p>针对npm配置的命令行操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set &lt;key&gt; &lt;value&gt; [--global]</span><br><span class="line">npm config get &lt;key&gt;</span><br><span class="line">npm config delete &lt;key&gt;</span><br><span class="line">npm config list</span><br><span class="line">npm config edit</span><br><span class="line">npm get &lt;key&gt;</span><br><span class="line">npm set &lt;key&gt; &lt;value&gt; [--global]</span><br></pre></td></tr></table></figure>

<p>在设置配置属性时属性值默认是被存储于用户配置文件中，如果加上<code>--global</code>，则被存储在全局配置文件中。</p>
<p>如果要查看npm的所有配置属性（包括默认配置），可以使用<code>npm config ls -l</code>。</p>
<p>如果要查看npm的各种配置的含义，可以使用<code>npm help config</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>代理</tag>
        <tag>配置</tag>
        <tag>npm</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁与悲观锁</title>
    <url>/2020/08/22/%E9%94%81/</url>
    <content><![CDATA[<h3 id="什么是乐观锁与悲观锁"><a href="#什么是乐观锁与悲观锁" class="headerlink" title="什么是乐观锁与悲观锁"></a>什么是乐观锁与悲观锁</h3><blockquote>
<p>乐观锁和悲观锁、见名知意，乐观锁设计的出发点是程序总是能够按照正确的，没有异常的情况发展；悲观锁的设计出发点是程序运行时总是会遇到异常。</p>
</blockquote>
<a id="more"></a>

<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞，直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/08/21/binary-tree/</url>
    <content><![CDATA[<p>数据结构总结——二叉树</p>
<p>总结常见的二叉树相关的算法以及代码实现</p>
<a id="more"></a>

<p><strong>二叉树定义</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><ul>
<li>递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归方法(同理可得中序遍历和后序遍历的递归方法)</span></span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        preorderTraversal(root.left);</span><br><span class="line">        preorderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>迭代</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">preOrderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        result.add(temp.val);</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        inorderTraversal(root.left);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        inorderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//迭代方法同前序遍历</span></span><br></pre></td></tr></table></figure>



<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postorderTraversal(root.left);</span><br><span class="line">        postorderTraversal(root.right);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代方法同前序遍历</span></span><br></pre></td></tr></table></figure>

<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS</span></span><br><span class="line">同前序遍历</span><br></pre></td></tr></table></figure>

<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            TreeNode cur = q.peek();</span><br><span class="line">            q.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            level.add(cur.val);</span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!level.isEmpty()) &#123;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="计算树的高度"><a href="#计算树的高度" class="headerlink" title="计算树的高度"></a>计算树的高度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftde = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightde = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftde, rightde) +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="计算树的直径"><a href="#计算树的直径" class="headerlink" title="计算树的直径"></a>计算树的直径</h3><ul>
<li><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">leetcode-543</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> result&gt;<span class="number">0</span>?result-<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = depth(node.left);</span><br><span class="line">    <span class="keyword">int</span> R = depth(node.right);</span><br><span class="line">    result = Math.max(result,L+R+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(R,L) +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="镜像二叉树"><a href="#镜像二叉树" class="headerlink" title="镜像二叉树"></a>镜像二叉树</h3><ul>
<li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">leetcode</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    mirrorTree(root.left);</span><br><span class="line">    mirrorTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="判断一个树是否镜像"><a href="#判断一个树是否镜像" class="headerlink" title="判断一个树是否镜像"></a>判断一个树是否镜像</h3><ul>
<li><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">leetcode-101</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root ==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(TreeNode mleft, TreeNode mright)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mleft ==<span class="keyword">null</span>&amp;&amp; mright == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mleft == <span class="keyword">null</span> || mright == <span class="keyword">null</span> || mleft.val != mright.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compare(mleft.left, mright.right) &amp;&amp; compare(mleft.right, mright.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉搜索树转化为累加树"><a href="#二叉搜索树转化为累加树" class="headerlink" title="二叉搜索树转化为累加树"></a>二叉搜索树转化为累加树</h3><ul>
<li><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">leetcode-538</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        convertBST(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用笔记</title>
    <url>/2020/08/04/git-notes/</url>
    <content><![CDATA[<p>记录一些常见的git命令吧</p>
<a id="more"></a>

<ul>
<li><p>创建分支</p>
<p><code>git branch branchName</code></p>
</li>
<li><p>切换分支</p>
<p><code>git checkout targetBranch</code></p>
</li>
<li><p>创建分支并切换到该分支</p>
<p><code>git checkout -b branchName</code></p>
</li>
<li><p>拉取远程分支到本地</p>
<p><code>git checkout -b localbranch origin/remoteBranch</code></p>
<p><code>git pull origin master</code></p>
</li>
<li><p>推送本地分支到远程</p>
<p><code>git push origin localBranch</code></p>
</li>
<li><p>删除本地分支</p>
<p><code>git branch -d localBranch</code></p>
</li>
<li><p>删除远程分支</p>
<p><code>git push origin :branchToboDeleted</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux使用笔记</title>
    <url>/2020/04/25/Linux%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>记录在Linux的使用过程中遇到的问题，以及应对办法</p>
<p>每一次遇到问题，先写下对应的解决方法，顺手写清楚为什么要这么解决，先给自己挖坑，如果有时间了，就回来填坑，从原理出发解释为什么这么解决</p>
</blockquote>
<a id="more"></a>

<h2 id="命令行程序在后台运行"><a href="#命令行程序在后台运行" class="headerlink" title="命令行程序在后台运行"></a>命令行程序在后台运行</h2><ul>
<li><p>用法：<code>nohup command &amp;</code> 或者<code>nohup command &gt; define.out 2&gt;&amp;1</code>  <em>(<code>command</code>指的是待执行命令)</em></p>
</li>
<li><p>注解：</p>
<ul>
<li><p>nohup：即no hang up，不挂起的意思。此命令指的是当前用户退出以后相应的进程继续执行。使<code>nohup</code>时如果程序有输出，默认情况下会输出到<code>nohup.out</code>文件中，如果需要指定输出文件，使用<code>nohup command &gt; define.out 2&gt;&amp;1</code>.</p>
<ol>
<li><p><code>command &gt; file.out</code></p>
<p>将输出内容放置入<code>file.out</code>文件，而不在屏幕上显示。</p>
</li>
<li><p><code>2&gt;&amp;1</code></p>
<p>将标准出错输出到标准输出，前面已经将标准输出重定向到了<code>define.out</code>文件，所以标准出错也会输出到<code>define.out</code>文件。</p>
<p><code>2</code>与<code>&amp;</code>结合表示错误重定向，<code>1</code>表示错误重定向到文件1，换成<code>2&gt;&amp;1</code>，<code>&amp;</code>与<code>1</code>表示标准输出，所以<code>2&gt;&amp;1</code>表示将错误重定向到标准输出.</p>
</li>
</ol>
</li>
<li><p>&amp;：使作业在后台运行。使用<code>&amp;</code>的时候在后台运行的作业如果有输出值，将会输出到屏幕上.</p>
</li>
<li><p><code>nohup command &amp;</code>与<code>command &amp;</code>区别</p>
<p><code>command &amp;</code>在后台运行，关掉终端会终止运行.</p>
<p><code>nohup command &amp;</code>后台运行，关掉终端不会有影响；</p>
<p><strong>使用nohup时，子进程收到父进程发来的hangup信号以后会忽略掉这个信号，达到不退出的目的；也可以通过<code>setsid</code>将父进程设置为<code>init进程</code>达到不退出的目的.</strong></p>
</li>
</ul>
</li>
<li><p>结束后台程序</p>
<p>使用<code>jobs -l</code>查看后台运行的命令，得到进程号之后，使用<code>kill pid</code>杀死该进程.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>使用命令行打开Ubuntu的护眼模式（Night Light）</title>
    <url>/2020/03/28/turnon-nightlight/</url>
    <content><![CDATA[<blockquote>
<p>使用命令行打开Ubuntu的Night Mode</p>
</blockquote>
<ul>
<li><p>Ubuntu上的护眼模式（Night Light）</p>
<p>Ubuntu的护眼模式很香，但是不是很好用，如果使用图形界面需要在设置中打开，对于懒癌晚期的患者不是很友好</p>
<a id="more"></a>
</li>
<li><p>解决方法</p>
<ul>
<li><p>终端中用命令打开</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开</span></span><br><span class="line">gsettings set org.gnome.settings-daemon.plugins.color night-light-enabled true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭</span></span><br><span class="line">gsettings set org.gnome.settings-daemon.plugins.color night-light-enabled false</span><br></pre></td></tr></table></figure>

<p>用了两分钟，体验极差，记不住，太长了，需要继续优化</p>
</li>
<li><p>优化方案</p>
<p>想到了<code>alias</code>，可以通过<code>alias</code>别名优化</p>
<ul>
<li>bash的<code>alias</code>不支持参数，需要用到function</li>
</ul>
<p><strong>大致思路</strong></p>
<p>将<code>alias</code>的内容定义成一个函数，由函数处理参数，然后调用函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function nightMode() &#123;</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">$</span><span class="bash"> nightMode &lt;<span class="literal">true</span>|<span class="literal">false</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最终实现</p>
<p>在当前用户的<code>home</code>目录下修改<code>.bashrc</code>文件，末尾追加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> turnon or turnoff nightlight</span></span><br><span class="line">alias nightmode='nightmode() &#123; gsettings set org.gnome.settings-daemon.plugins.color night-light-enabled $1;&#125;; nightmode'</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用方法</p>
<p>当前用户任意位置打开终端输入<code>nightmode true</code>或者<code>nightmode false</code>打开或者关闭护眼模式</p>
</li>
</ul>
</li>
<li><p>END</p>
</li>
</ul>
]]></content>
      <categories>
        <category>奇淫技巧</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>CLI</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下使用Git出现中文乱码</title>
    <url>/2020/02/13/git%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p>Windows下使用Git查看git log的时候出现乱码</p>
</blockquote>
<ul>
<li><strong>现象</strong><ul>
<li><code>cmd</code> <code>powershell</code>都是乱码</li>
<li>idea的<code>Terminal</code>终端也显示乱码</li>
<li><code>Git Bash</code>可以正常显示中文</li>
</ul>
</li>
</ul>
<a id="more"></a>

<img src=" http://images.wpt6.cn/20200214-1.jpg" alt="powershell使用Git中文乱码" style="zoom:80%;" />

<img src=" http://images.wpt6.cn/20200214-2.jpg" alt="cmd使用Git中文乱码" style="zoom:80%;" />

<p><img src="http://images.wpt6.cn/20200214-3.jpg" alt="Gitbash显示中文正常"></p>
<ul>
<li><p><strong>解决方法</strong></p>
<ul>
<li><p>方法一：<em>推荐</em></p>
<p>设置一条<code>LESSCHARSET=UTF-8</code>的环境变量–系统变量</p>
<img src=" http://images.wpt6.cn/20200214-4.jpg" alt="设置系统变量" style="zoom:80%;" />

<p>设置完成，重新打开终端使用Git</p>
</li>
<li><p>方法二：</p>
<p>设置一条<code>LESSCHARSET=UTF-8</code>的环境变量–用户变量</p>
<img src=" http://images.wpt6.cn/20200214-5.jpg" alt="设置用户变量" style="zoom:80%;" />

<p><strong>注意：此时在idea中使用还是会出现中文乱码</strong></p>
<ul>
<li>原因：在idea中的<code>cmd</code> <code>powershell</code>只加载了系统变量并没有加载用户变量，需要在idea中重新设置一条<code>LESSCHARSET=UTF-8</code>的配置</li>
</ul>
<p><img src="http://images.wpt6.cn/20200214-6.jpg" alt="idea中添加配置"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>git</tag>
        <tag>乱码</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是回源？CDN回源与域名回源各是什么？</title>
    <url>/2020/02/03/back-to-source/</url>
    <content><![CDATA[<blockquote>
<p>配置七牛云的时候，一直不是很清楚回源相关的概念，学习记录一下。</p>
</blockquote>
<p>理解什么是回源之前，需要明白什么是CDN。</p>
<h5 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h5><p> 全称:<code>Content Delivery Network或Content Ddistribute Network</code>，即内容分发网络 。其搭建的思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，尽量使内容传输的更快更稳定。<a id="more"></a>CDN通过在网络边缘部署边缘服务器，依靠CDN中心平台的负载均衡、内容分发及调度等功能，使用户就近获取所需的内容，降低网络拥堵，提高用户访问响应速度和命中率。所以基本上CDN就是广泛采用各种缓存服务器，使得用户的请求直接由这些缓存服务器响应，加快了响应速度；只有在用户请求的资源在缓存服务器上没有找到或者请求访问的资源在源站点服务器上已经修改过的情况下，缓存服务器才会去访问源站点服务器以获取最新的资源。</p>
<p>简单来说，使用CDN的目的是使用户能够更快速、更稳定的获取网络内容。举个例子：京东自营的商品，拥有本地仓库，大多数能够在当日或者次日送达，相比单一发货地的网店快很多。众多本地仓库就是CDN，加快了货物的运送。</p>
<blockquote>
<p>下图是一个CDN架构的基本原理图，实际使用中的架构会复杂得多，分级分区域等。</p>
</blockquote>
<p><img src="http://images.wpt6.cn/cdn_overview.png" alt="CDN架构图"></p>
<h5 id="回源"><a href="#回源" class="headerlink" title="回源"></a>回源</h5><p>什么是回源？客户端发送请求报文时，响应该请求报文的是源站点的服务器，而不是各节点上的缓存服务器，那么这个过程相对于通过各节点上的缓存服务器来响应的话就称作为回源。 </p>
<p><strong>什么情况下会回源？</strong></p>
<ol>
<li>用户访问时，如节点上无缓存，则会回源拉取资源</li>
<li>CDN 节点上的文件超时过期，会回源拉取资源</li>
<li>若为不缓存文件，用户访问时，会直接回源</li>
<li>未忽略 URL 参数域名，使用该形式域名带参数访问资源，会直接回源</li>
</ol>
<p><strong>如何计算回源比？</strong></p>
<p>回源比分为回源请求数比例及回源流量比例两种</p>
<p><strong>回源请求数比：</strong>统计数据来自所有边缘节点上的请求记录，其中，对于没有缓存或缓存过期（可缓存）的请求以及不可缓存的请求，均计入回源请求中，其他直接命中缓存的，则为命中请求。 </p>
<p>​        <code>回源请求数/（回源请求数+用户发送的请求数）</code> </p>
<p><strong>回源流量比：</strong>回源流量是回源请求文件大小产生的流量和请求本身产生的流量 </p>
<p>​         <code>回源流量比=回源流量/回源流量+用户请求访问的流量</code></p>
<p><strong>域名回源：</strong> 在搜索引擎中所谓的 域名回源就是搜索引擎的蜘蛛在爬行的过程中直接抓取源地址上的内容而不是存在各个节点（CDN）上的缓存内容 </p>
<h5 id="参考图书与博客"><a href="#参考图书与博客" class="headerlink" title="参考图书与博客"></a>参考图书与博客</h5><ul>
<li>CDN技术详解 </li>
<li><a href="https://www.cnblogs.com/losbyday/p/5843960.html" target="_blank" rel="noopener">CDN技术详解-博客</a></li>
<li><a href="https://segmentfault.com/a/1190000000538796" target="_blank" rel="noopener">CDN工作原理</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1439913" target="_blank" rel="noopener">CDN多级缓存</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>CDN</category>
      </categories>
      <tags>
        <tag>CDN</tag>
        <tag>回源</tag>
        <tag>缓存</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】H2O 生成</title>
    <url>/2020/01/30/H2O/</url>
    <content><![CDATA[<blockquote>
<p>原来，猪的日子也很不好过，吃了睡睡了吃，实在是太无聊了</p>
</blockquote>
<h4 id="【LeetCode】1117-H2O-生成"><a href="#【LeetCode】1117-H2O-生成" class="headerlink" title="【LeetCode】1117. H2O 生成"></a>【LeetCode】1117. H2O 生成</h4><p>现在有两种线程，氢 oxygen 和氧 hydrogen，你的目标是组织这两种线程来产生水分子。</p>
<p>存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。</p>
<p>氢和氧线程会被分别给予 releaseHydrogen 和 releaseOxygen 方法来允许它们突破屏障。</p>
<p>这些线程应该三三成组突破屏障并能立即组合产生一个水分子。</p>
<p>你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。</p>
<a id="more"></a>

<p>换句话说:</p>
<p>​    如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。<br>​    如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。<br>​    书写满足这些限制条件的氢、氧线程同步代码。</p>
<p>示例 1:</p>
<p><code>输入: &quot;HOH&quot;</code><br><code>输出: &quot;HHO&quot;</code><br><code>解释: &quot;HOH&quot; 和 &quot;OHH&quot; 依然都是有效解。</code><br>示例 2:</p>
<p><code>输入: &quot;OOHHHH&quot;</code><br><code>输出: &quot;HHOHHO&quot;</code><br><code>解释: &quot;HOHHHO&quot;, &quot;OHHHHO&quot;, &quot;HHOHOH&quot;, &quot;HOHHOH&quot;, &quot;OHHHOH&quot;, &quot;HHOOHH&quot;, &quot;HOHOHH&quot; 和 &quot;OHHOHH&quot; 依然都是有效解。</code></p>
<p>限制条件:</p>
<ul>
<li>输入字符串的总长将会是 3n, 1 ≤ n ≤ 50；</li>
<li>输入字符串中的 “H” 总数将会是 2n；</li>
<li>输入字符串中的 “O” 总数将会是 n。</li>
</ul>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H2O</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">H2O</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (h == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        releaseHydrogen.run();</span><br><span class="line">        ++h;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        releaseOxygen.run();</span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】交替打印FooBar</title>
    <url>/2020/01/29/printfoobar/</url>
    <content><![CDATA[<blockquote>
<p>继续划水</p>
</blockquote>
<h3 id="【LeetCode】1115-交替打印FooBar"><a href="#【LeetCode】1115-交替打印FooBar" class="headerlink" title="【LeetCode】1115. 交替打印FooBar"></a>【LeetCode】1115. 交替打印FooBar</h3><p>我们提供一个类：</p>
<p>两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。</p>
<p>请设计修改程序，以确保 “foobar” 被输出 n 次。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">"foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">"bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>示例 1:</p>
<p><code>输入: n = 1</code><br><code>输出: &quot;foobar&quot;</code><br><code>解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，&quot;foobar&quot; 将被输出一次。</code></p>
<p>示例 2:</p>
<p><code>输入: n = 2</code><br><code>输出: &quot;foobarfoobar&quot;</code><br><code>解释: &quot;foobar&quot; 将被输出两次。</code></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;   <span class="comment">// f-foo, t-bar</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// printFoo.run() outputs "foo". Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">while</span>( flag) wait();</span><br><span class="line">            printFoo.run();</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// printBar.run() outputs "bar". Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">while</span>( !flag) wait();</span><br><span class="line">            printBar.run();</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】交替打印字符串</title>
    <url>/2020/01/28/FizzBuzz/</url>
    <content><![CDATA[<blockquote>
<p>肺炎赋闲在家，水一些简单题打发时间吧</p>
</blockquote>
<h3 id="【LeetCode】1195-交替打印字符串"><a href="#【LeetCode】1195-交替打印字符串" class="headerlink" title="【LeetCode】1195. 交替打印字符串"></a>【LeetCode】1195. 交替打印字符串</h3><p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</p>
<p>如果这个数字可以被 3 整除，输出 “fizz”。<br>如果这个数字可以被 5 整除，输出 “buzz”。<br>如果这个数字可以同时被 3 和 5 整除，输出 “fizzbuzz”。<br>例如，当 n = 15，输出： 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。</p>
<a id="more"></a>

<p>假设有这么一个类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class FizzBuzz &#123;</span><br><span class="line">  public FizzBuzz(int n) &#123; ... &#125;               &#x2F;&#x2F; constructor</span><br><span class="line">  public void fizz(printFizz) &#123; ... &#125;          &#x2F;&#x2F; only output &quot;fizz&quot;</span><br><span class="line">  public void buzz(printBuzz) &#123; ... &#125;          &#x2F;&#x2F; only output &quot;buzz&quot;</span><br><span class="line">  public void fizzbuzz(printFizzBuzz) &#123; ... &#125;  &#x2F;&#x2F; only output &quot;fizzbuzz&quot;</span><br><span class="line">  public void number(printNumber) &#123; ... &#125;      &#x2F;&#x2F; only output the numbers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>请你实现一个有四个线程的多线程版  FizzBuzz， 同一个 FizzBuzz 实例会被如下四个线程使用：</p>
<p><code>线程A将调用 fizz() 来判断是否能被 3 整除，如果可以，则输出 fizz。</code><br><code>线程B将调用 buzz() 来判断是否能被 5 整除，如果可以，则输出 buzz。</code><br><code>线程C将调用 fizzbuzz() 来判断是否同时能被 3 和 5 整除，如果可以，则输出 fizzbuzz。</code><br><code>线程D将调用 number() 来实现输出既不能被 3 整除也不能被 5 整除的数字。</code></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一个简单的同步问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> iCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (iCount &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (iCount % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                wait();</span><br><span class="line">                <span class="keyword">if</span> (iCount &gt; n) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printFizz.run();</span><br><span class="line">            iCount++;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (iCount &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (iCount % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                wait();</span><br><span class="line">                <span class="keyword">if</span> (iCount &gt; n) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printBuzz.run();</span><br><span class="line">            iCount++;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (iCount &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (iCount % <span class="number">3</span> != <span class="number">0</span> || iCount % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                wait();</span><br><span class="line">                <span class="keyword">if</span> (iCount &gt; n) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printFizzBuzz.run();</span><br><span class="line">            iCount++;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (iCount &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (iCount % <span class="number">3</span> == <span class="number">0</span> || iCount % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                wait();</span><br><span class="line">                <span class="keyword">if</span> (iCount &gt; n) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(iCount++);</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】int32 to IPv4</title>
    <url>/2020/01/27/int32-to-IPv4/</url>
    <content><![CDATA[<h3 id="【CodeWars】int32-to-IPv4"><a href="#【CodeWars】int32-to-IPv4" class="headerlink" title="【CodeWars】int32 to IPv4"></a>【CodeWars】int32 to IPv4</h3><p>Take the following IPv4 address: <code>128.32.10.1</code></p>
<p>This address has 4 octets where each octet is a single byte (or 8 bits).</p>
<ul>
<li>1st octet <code>128</code> has the binary representation: <code>10000000</code></li>
<li>2nd octet <code>32</code> has the binary representation: <code>00100000</code></li>
<li>3rd octet <code>10</code> has the binary representation: <code>00001010</code></li>
<li>4th octet <code>1</code> has the binary representation: <code>00000001</code></li>
</ul>
<p>So <code>128.32.10.1</code> == <code>10000000.00100000.00001010.00000001</code></p>
<p>Because the above IP address has 32 bits, we can represent it as the unsigned 32 bit number: <code>2149583361</code></p>
<p>Complete the function that takes an unsigned 32 bit number and returns a string representation of its IPv4 address.</p>
<a id="more"></a>

<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2149583361 ==&gt; "128.32.10.1"</span><br><span class="line">32         ==&gt; "0.0.0.32"</span><br><span class="line">0          ==&gt; "0.0.0.0"</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>按照题目描述，点分十进制的IP地址转换成点分二进制之后，去掉分隔符后转化成unsigned 32位整数。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">128.32.10.1 ---&gt; 10000000.00100000.00001010.00000001 ---&gt; 10000000001000000000101000000001 ---&gt; 2149583361</span><br></pre></td></tr></table></figure>

<p>此题最终思路只需将上述转化过程逆序实现即可。</p>
<p>利用与运算取最后8位二进制：2149583361 &amp; 0xff</p>
<p>利用无符号右移、与运算取倒数第二个8位二进制：2149583361&gt;&gt;&gt;8 &amp; 0xff</p>
<p>同理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kata</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longToIP</span><span class="params">(<span class="keyword">long</span> ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%d.%d.%d.%d"</span>,ip &gt;&gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>,ip &gt;&gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>,ip &gt;&gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>,ip &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>每日一题</category>
        <category>CodeWars</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>CodeWars</tag>
        <tag>BINARY</tag>
      </tags>
  </entry>
  <entry>
    <title>HelloWorld</title>
    <url>/2020/01/25/HelloWorld/</url>
    <content><![CDATA[<p>经过一番折腾，终于把GitHub Page 弄好了</p>
<a id="more"></a>

<p>距离自己买的服务器过期已经好长时间了，中间又有很多事情，一直都没机会再处理自己博客的事情，原博客的文章没来得及备份，重新开始吧。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
</search>
