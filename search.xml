<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【每日一题】交替打印字符串</title>
    <url>/FizzBuzz/</url>
    <content><![CDATA[<blockquote>
<p>肺炎赋闲在家，水一些简单题打发时间吧</p>
</blockquote>
<h3 id="【LeetCode】1195-交替打印字符串"><a href="#【LeetCode】1195-交替打印字符串" class="headerlink" title="【LeetCode】1195. 交替打印字符串"></a>【LeetCode】1195. 交替打印字符串</h3><p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</p>
<p>如果这个数字可以被 3 整除，输出 “fizz”。<br>如果这个数字可以被 5 整除，输出 “buzz”。<br>如果这个数字可以同时被 3 和 5 整除，输出 “fizzbuzz”。<br>例如，当 n &#x3D; 15，输出： 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。</p>
<span id="more"></span>

<p>假设有这么一个类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class FizzBuzz &#123;</span><br><span class="line">  public FizzBuzz(int n) &#123; ... &#125;               // constructor</span><br><span class="line">  public void fizz(printFizz) &#123; ... &#125;          // only output &quot;fizz&quot;</span><br><span class="line">  public void buzz(printBuzz) &#123; ... &#125;          // only output &quot;buzz&quot;</span><br><span class="line">  public void fizzbuzz(printFizzBuzz) &#123; ... &#125;  // only output &quot;fizzbuzz&quot;</span><br><span class="line">  public void number(printNumber) &#123; ... &#125;      // only output the numbers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>请你实现一个有四个线程的多线程版  FizzBuzz， 同一个 FizzBuzz 实例会被如下四个线程使用：</p>
<p><code>线程A将调用 fizz() 来判断是否能被 3 整除，如果可以，则输出 fizz。</code><br><code>线程B将调用 buzz() 来判断是否能被 5 整除，如果可以，则输出 buzz。</code><br><code>线程C将调用 fizzbuzz() 来判断是否同时能被 3 和 5 整除，如果可以，则输出 fizzbuzz。</code><br><code>线程D将调用 number() 来实现输出既不能被 3 整除也不能被 5 整除的数字。</code></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一个简单的同步问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FizzBuzz</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FizzBuzz</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">iCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz.run() outputs &quot;fizz&quot;.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (iCount &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (iCount % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                wait();</span><br><span class="line">                <span class="keyword">if</span> (iCount &gt; n) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printFizz.run();</span><br><span class="line">            iCount++;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs &quot;buzz&quot;.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (iCount &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (iCount % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                wait();</span><br><span class="line">                <span class="keyword">if</span> (iCount &gt; n) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printBuzz.run();</span><br><span class="line">            iCount++;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs &quot;fizzbuzz&quot;.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (iCount &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (iCount % <span class="number">3</span> != <span class="number">0</span> || iCount % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                wait();</span><br><span class="line">                <span class="keyword">if</span> (iCount &gt; n) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printFizzBuzz.run();</span><br><span class="line">            iCount++;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (iCount &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (iCount % <span class="number">3</span> == <span class="number">0</span> || iCount % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                wait();</span><br><span class="line">                <span class="keyword">if</span> (iCount &gt; n) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(iCount++);</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】H2O 生成</title>
    <url>/H2O/</url>
    <content><![CDATA[<blockquote>
<p>原来，猪的日子也很不好过，吃了睡睡了吃，实在是太无聊了</p>
</blockquote>
<h4 id="【LeetCode】1117-H2O-生成"><a href="#【LeetCode】1117-H2O-生成" class="headerlink" title="【LeetCode】1117. H2O 生成"></a>【LeetCode】1117. H2O 生成</h4><p>现在有两种线程，氢 oxygen 和氧 hydrogen，你的目标是组织这两种线程来产生水分子。</p>
<p>存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。</p>
<p>氢和氧线程会被分别给予 releaseHydrogen 和 releaseOxygen 方法来允许它们突破屏障。</p>
<p>这些线程应该三三成组突破屏障并能立即组合产生一个水分子。</p>
<p>你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。</p>
<span id="more"></span>

<p>换句话说:</p>
<p>​	如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。<br>​	如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。<br>​	书写满足这些限制条件的氢、氧线程同步代码。</p>
<p>示例 1:</p>
<p><code>输入: &quot;HOH&quot;</code><br><code>输出: &quot;HHO&quot;</code><br><code>解释: &quot;HOH&quot; 和 &quot;OHH&quot; 依然都是有效解。</code><br>示例 2:</p>
<p><code>输入: &quot;OOHHHH&quot;</code><br><code>输出: &quot;HHOHHO&quot;</code><br><code>解释: &quot;HOHHHO&quot;, &quot;OHHHHO&quot;, &quot;HHOHOH&quot;, &quot;HOHHOH&quot;, &quot;OHHHOH&quot;, &quot;HHOOHH&quot;, &quot;HOHOHH&quot; 和 &quot;OHHOHH&quot; 依然都是有效解。</code></p>
<p>限制条件:</p>
<ul>
<li>输入字符串的总长将会是 3n, 1 ≤ n ≤ 50；</li>
<li>输入字符串中的 “H” 总数将会是 2n；</li>
<li>输入字符串中的 “O” 总数将会是 n。</li>
</ul>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">H2O</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">H2O</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (h == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        releaseHydrogen.run();</span><br><span class="line">        ++h;</span><br><span class="line">        <span class="built_in">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        releaseOxygen.run();</span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>HelloWorld</title>
    <url>/HelloWorld/</url>
    <content><![CDATA[<p>经过一番折腾，终于把GitHub Page 弄好了</p>
<span id="more"></span>

<p>距离自己买的服务器过期已经好长时间了，中间又有很多事情，一直都没机会再处理自己博客的事情，原博客的文章没来得及备份，重新开始吧。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合知识点整理</title>
    <url>/Java%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>Java常见的关于集合框架的面试知识点整理。</p>
<span id="more"></span>

<h3 id="List、Set、Map三者区别"><a href="#List、Set、Map三者区别" class="headerlink" title="List、Set、Map三者区别"></a>List、Set、Map三者区别</h3><ul>
<li>List：存储一组不唯一（可以有多个元素引用相同的对象）、有序的对象</li>
<li>Set：不允许重复的集合。不会有多个元素引用相同的对象</li>
<li>Map：使用键值对存储，Map会维护与Key有关联的值，两个Key可以引用相同的对象，但是Key不能重复，典型的Key是String类型，也可以是任意对象</li>
</ul>
<h3 id="ArrayList与LinkedList区别"><a href="#ArrayList与LinkedList区别" class="headerlink" title="ArrayList与LinkedList区别"></a>ArrayList与LinkedList区别</h3><ul>
<li>多线程安全：两者都是不同步的，无法保证线程安全</li>
<li>底层数据结构：<code>ArrayList</code>底层使用<code>Object</code>数组；<code>LinkedList</code>底层使用的是<strong>双向链表</strong></li>
<li>插入删除与元素位置的关系：<ul>
<li><code>ArrayList</code>使用数组存储，插入和删除的时候时间复杂度受到元素位置影响。</li>
<li><code>LinkedList</code>采用链表存储，插入删除不受其位置的影响，时间复杂度近似O(n)。</li>
</ul>
</li>
<li>是否支持快速随机访问：<code>LinkedList</code>不支持，<code>ArrayList</code>支持。</li>
<li>内存占用：<code>ArrayList</code>的空间浪费体现在list列表的结尾一定会预留一定的容量空间。<code>LinkedList</code>的空间浪费在于每一个元素都要存储前驱和后继节点。</li>
</ul>
<h3 id="ArrayList与Vector的区别"><a href="#ArrayList与Vector的区别" class="headerlink" title="ArrayList与Vector的区别"></a>ArrayList与Vector的区别</h3><p><code>Vector</code>类中的所有方法都是同步的。可以保证多线程安全，但是在单一线程访问Vector中，同步操作会浪费大量的时间。</p>
<p><code>ArrayList</code>不是同步的，在多线程场景下不适用。</p>
<h3 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h3><p>以无参形式构造<code>ArrayList</code>的时候，实际上是初始化赋值一个空数组，当真正添加第一个数组元素的操作时，数组扩容为10。ArrayList对象的创建类似单例模式中的懒汉式，延迟赋值针对内存优化。</p>
<p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90">参考资料</a></p>
<h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ol>
<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果保证线程安全的话就使用 ConcurrentHashMap ）</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<h3 id="HashMap-和-HashSet区别"><a href="#HashMap-和-HashSet区别" class="headerlink" title="HashMap 和 HashSet区别"></a>HashMap 和 HashSet区别</h3><p>HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
<table>
<thead>
<tr>
<th align="left">HashMap</th>
<th align="left">HashSet</th>
</tr>
</thead>
<tbody><tr>
<td align="left">实现了Map接口</td>
<td align="left">实现Set接口</td>
</tr>
<tr>
<td align="left">存储键值对</td>
<td align="left">仅存储对象</td>
</tr>
<tr>
<td align="left">调用 <code>put（）</code>向map中添加元素</td>
<td align="left">调用 <code>add（）</code>方法向Set中添加元素</td>
</tr>
<tr>
<td align="left">HashMap使用键（Key）计算Hashcode</td>
<td align="left">HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<h3 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux使用笔记</title>
    <url>/Linux%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>记录在Linux的使用过程中遇到的问题，以及应对办法</p>
<p>每一次遇到问题，先写下对应的解决方法，顺手写清楚为什么要这么解决，先给自己挖坑，如果有时间了，就回来填坑，从原理出发解释为什么这么解决</p>
</blockquote>
<span id="more"></span>

<h2 id="命令行程序在后台运行"><a href="#命令行程序在后台运行" class="headerlink" title="命令行程序在后台运行"></a>命令行程序在后台运行</h2><ul>
<li><p>用法：<code>nohup command &amp;</code> 或者<code>nohup command &gt; define.out 2&gt;&amp;1</code>  <em>(<code>command</code>指的是待执行命令)</em></p>
</li>
<li><p>注解：</p>
<ul>
<li><p>nohup：即no hang up，不挂起的意思。此命令指的是当前用户退出以后相应的进程继续执行。使<code>nohup</code>时如果程序有输出，默认情况下会输出到<code>nohup.out</code>文件中，如果需要指定输出文件，使用<code>nohup command &gt; define.out 2&gt;&amp;1</code>.</p>
<ol>
<li><p><code>command &gt; file.out</code></p>
<p>将输出内容放置入<code>file.out</code>文件，而不在屏幕上显示。</p>
</li>
<li><p><code>2&gt;&amp;1</code></p>
<p>将标准出错输出到标准输出，前面已经将标准输出重定向到了<code>define.out</code>文件，所以标准出错也会输出到<code>define.out</code>文件。</p>
<p><code>2</code>与<code>&amp;</code>结合表示错误重定向，<code>1</code>表示错误重定向到文件1，换成<code>2&gt;&amp;1</code>，<code>&amp;</code>与<code>1</code>表示标准输出，所以<code>2&gt;&amp;1</code>表示将错误重定向到标准输出.</p>
</li>
</ol>
</li>
<li><p>&amp;：使作业在后台运行。使用<code>&amp;</code>的时候在后台运行的作业如果有输出值，将会输出到屏幕上.</p>
</li>
<li><p><code>nohup command &amp;</code>与<code>command &amp;</code>区别</p>
<p><code>command &amp;</code>在后台运行，关掉终端会终止运行.</p>
<p><code>nohup command &amp;</code>后台运行，关掉终端不会有影响；</p>
<p><strong>使用nohup时，子进程收到父进程发来的hangup信号以后会忽略掉这个信号，达到不退出的目的；也可以通过<code>setsid</code>将父进程设置为<code>init进程</code>达到不退出的目的.</strong></p>
</li>
</ul>
</li>
<li><p>结束后台程序</p>
<p>使用<code>jobs -l</code>查看后台运行的命令，得到进程号之后，使用<code>kill pid</code>杀死该进程.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是回源？CDN回源与域名回源各是什么？</title>
    <url>/back-to-source/</url>
    <content><![CDATA[<blockquote>
<p>配置七牛云的时候，一直不是很清楚回源相关的概念，学习记录一下。</p>
</blockquote>
<p>理解什么是回源之前，需要明白什么是CDN。</p>
<h5 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h5><p> 全称:<code>Content Delivery Network或Content Ddistribute Network</code>，即内容分发网络 。其搭建的思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，尽量使内容传输的更快更稳定。<span id="more"></span>CDN通过在网络边缘部署边缘服务器，依靠CDN中心平台的负载均衡、内容分发及调度等功能，使用户就近获取所需的内容，降低网络拥堵，提高用户访问响应速度和命中率。所以基本上CDN就是广泛采用各种缓存服务器，使得用户的请求直接由这些缓存服务器响应，加快了响应速度；只有在用户请求的资源在缓存服务器上没有找到或者请求访问的资源在源站点服务器上已经修改过的情况下，缓存服务器才会去访问源站点服务器以获取最新的资源。</p>
<p>简单来说，使用CDN的目的是使用户能够更快速、更稳定的获取网络内容。举个例子：京东自营的商品，拥有本地仓库，大多数能够在当日或者次日送达，相比单一发货地的网店快很多。众多本地仓库就是CDN，加快了货物的运送。</p>
<blockquote>
<p>下图是一个CDN架构的基本原理图，实际使用中的架构会复杂得多，分级分区域等。</p>
</blockquote>
<p><img src="http://images.wpt6.cn/cdn_overview.png" alt="CDN架构图"></p>
<h5 id="回源"><a href="#回源" class="headerlink" title="回源"></a>回源</h5><p>什么是回源？客户端发送请求报文时，响应该请求报文的是源站点的服务器，而不是各节点上的缓存服务器，那么这个过程相对于通过各节点上的缓存服务器来响应的话就称作为回源。 </p>
<p><strong>什么情况下会回源？</strong></p>
<ol>
<li>用户访问时，如节点上无缓存，则会回源拉取资源</li>
<li>CDN 节点上的文件超时过期，会回源拉取资源</li>
<li>若为不缓存文件，用户访问时，会直接回源</li>
<li>未忽略 URL 参数域名，使用该形式域名带参数访问资源，会直接回源</li>
</ol>
<p><strong>如何计算回源比？</strong></p>
<p>回源比分为回源请求数比例及回源流量比例两种</p>
<p><strong>回源请求数比：</strong>统计数据来自所有边缘节点上的请求记录，其中，对于没有缓存或缓存过期（可缓存）的请求以及不可缓存的请求，均计入回源请求中，其他直接命中缓存的，则为命中请求。 </p>
<p>​		<code>回源请求数/（回源请求数+用户发送的请求数）</code> </p>
<p><strong>回源流量比：</strong>回源流量是回源请求文件大小产生的流量和请求本身产生的流量 </p>
<p>​		 <code>回源流量比=回源流量/回源流量+用户请求访问的流量</code></p>
<p><strong>域名回源：</strong> 在搜索引擎中所谓的 域名回源就是搜索引擎的蜘蛛在爬行的过程中直接抓取源地址上的内容而不是存在各个节点（CDN）上的缓存内容 </p>
<h5 id="参考图书与博客"><a href="#参考图书与博客" class="headerlink" title="参考图书与博客"></a>参考图书与博客</h5><ul>
<li>CDN技术详解 </li>
<li><a href="https://www.cnblogs.com/losbyday/p/5843960.html">CDN技术详解-博客</a></li>
<li><a href="https://segmentfault.com/a/1190000000538796">CDN工作原理</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1439913">CDN多级缓存</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>CDN</category>
      </categories>
      <tags>
        <tag>CDN</tag>
        <tag>回源</tag>
        <tag>缓存</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>在OS X上配置JAVA_HOME环境变量</title>
    <url>/config-java-home-on-mac/</url>
    <content><![CDATA[<p>在Mac上配置Java开发环境的时候，遇到了一些问题，搜索一番下来之后，更困惑了，各类教程基本上是复制粘贴，而且还很老旧，或者按照Linux系列的系统进行配置，部分情况下配置无法生效，特意搜了一下官方文档，总结一下最新的配置方法。</p>
<span id="more"></span>

<p><strong>系统环境</strong></p>
<p>系统版本：macOS Catalina 10.15.6</p>
<p>Shell：zsh</p>
<p><a href="https://developer.apple.com/library/archive/qa/qa1170/_index.html">官方链接</a></p>
<blockquote>
<p>Many Java applications need to know the location of a <code>$JAVA_HOME</code> directory. The <code>$JAVA_HOME</code> on Mac OS X should be found using the <code>/usr/libexec/java_home</code> command line tool on Mac OS X 10.5 or later. On older Mac OS X versions where the tool does not exist, use the fixed path “<code>/Library/Java/Home</code>“. The <code>/usr/libexec/java_home</code> tool dynamically finds the top Java version specified in Java Preferences for the current user. This path allows access to the <code>bin</code> subdirectory where command line tools such as <code>java</code>, <code>javac</code>, etc. exist as on other platforms. The tool <code>/usr/libexec/java_home</code> allows you to specify a particular CPU architecture and Java platform version when locating a <code>$JAVA_HOME</code>.</p>
<p>Another advantage of dynamically finding this path, as opposed to hardcoding the fixed endpoint, is that it is updated when a new version of Java is downloaded via Software Update or installed with a newer version of Mac OS X. For this reason, it is important that developers do not install files in the JDKs inside of <code>/System</code>, since the changes will be lost with subsequent updates by newer versions of Java.</p>
<p>To obtain the path to the currently executing <code>$JAVA_HOME</code>, use the <code>java.home</code> System property.</p>
</blockquote>
<p><strong>developer.apple.com中明确指出了，10.5以后的系统版本使用<code>/usr/libexec/java_home</code>进行配置。</strong></p>
<p>看一下<code>/usr/libexec/java_home</code>究竟是个什么东西</p>
<p><img src="http://images.wpt6.cn/blog/2020-09-13-23-57-38.png"></p>
<p><strong>为什么要使用&#x2F; usr &#x2F; libexec &#x2F; java_home？</strong><br>此<code>java_home</code>可以返回在Java首选项中为当前用户指定的Java版本。</p>
<p>例如：</p>
<p><img src="http://images.wpt6.cn/blog/2020-09-14-00-05-42.png"></p>
<p>通过-V查看当前安装的所有Java的版本</p>
<p>可以使用java_home -v &lt;JDK版本号&gt;来进行切换</p>
<p>参考：<a href="https://www.jianshu.com/p/af79ae7f732c">在 Mac OS 上管理多个 jdk 版本</a></p>
<hr>
<p>除去上面配置Java_HOME的一点，还有zsh和shell的区别，众多教程里面也没有注明，不加分辨，盲目复制会走不少弯路。</p>
<p>重要原因在于：macOS Catalina 默认的shell环境是zsh，zsh和shell的加载配置文件是不一样的，按照习惯，在<code>/etc/profile</code>或者<code>～/.bashrc</code>中添加环境变量信息会不起作用。</p>
<p>看一下<code>man zsh</code>的说明</p>
<blockquote>
<p><strong>STARTUP&#x2F;SHUTDOWN</strong> <strong>FILES</strong></p>
<p>​    Commands are first read from <strong>&#x2F;etc&#x2F;zshenv</strong>; this cannot be overridden. Subsequent be-</p>
<p>​    haviour is modified by the <strong>RCS</strong> and <strong>GLOBAL_RCS</strong> options; the former affects all startup</p>
<p>​    files, while the second only affects global startup files (those shown here with an</p>
<p>​    path starting with a <strong>&#x2F;</strong>). If one of the options is unset at any point, any subsequent</p>
<p>​    startup file(s) of the corresponding type will not be read. It is also possible for a</p>
<p>​    file in <strong>$ZDOTDIR</strong> to re-enable <strong>GLOBAL_RCS</strong>. Both <strong>RCS</strong> and <strong>GLOBAL_RCS</strong> are set by default.</p>
<p>​    Commands are then read from <strong>$ZDOTDIR&#x2F;.zshenv</strong>. If the shell is a login shell, commands</p>
<p>​    are read from <strong>&#x2F;etc&#x2F;zprofile</strong> and then <strong>$ZDOTDIR&#x2F;.zprofile</strong>. Then, if the shell is inter-</p>
<p>​    active, commands are read from <strong>&#x2F;etc&#x2F;zshrc</strong> and then <strong>$ZDOTDIR&#x2F;.zshrc</strong>. Finally, if the</p>
<p>​    shell is a login shell, <strong>&#x2F;etc&#x2F;zlogin</strong> and <strong>$ZDOTDIR&#x2F;.zlogin</strong> are read.</p>
<p>​    When a login shell exits, the files <strong>$ZDOTDIR&#x2F;.zlogout</strong> and then <strong>&#x2F;etc&#x2F;zlogout</strong> are read.</p>
<p>​    This happens with either an explicit exit via the <strong>exit</strong> or <strong>logout</strong> commands, or an</p>
<p>​    implicit exit by reading end-of-file from the terminal. However, if the shell termi-</p>
<p>​    nates due to <strong>exec</strong>‘ing another process, the logout files are not read. These are also</p>
<p>​    affected by the <strong>RCS</strong> and <strong>GLOBAL_RCS</strong> options. Note also that the <strong>RCS</strong> option affects the</p>
<p>​    saving of history files, i.e. if <strong>RCS</strong> is unset when the shell exits, no history file</p>
<p>​    will be saved.</p>
<p>​    If <strong>ZDOTDIR</strong> is unset, <strong>HOME</strong> is used instead. Files listed above as being in <strong>&#x2F;etc</strong> may be</p>
<p>​    in another directory, depending on the installation.</p>
<p>​    As <strong>&#x2F;etc&#x2F;zshenv</strong> is run for all instances of zsh, it is important that it be kept as</p>
<p>​    small as possible. In particular, it is a good idea to put code that does not need to</p>
<p>​    be run for every single shell behind a test of the form &#96;<strong>if</strong> <strong>[[</strong> <strong>-o</strong> <strong>rcs</strong> <strong>]];</strong> <strong>then</strong> <strong>…</strong>‘ so</p>
<p>​    that it will not be executed when zsh is invoked with the &#96;<strong>-f</strong>‘ option.</p>
<p>​    Any of these files may be pre-compiled with the <strong>zcompile</strong> builtin command (see zsh-</p>
<p>​    builtins(1)).  If a compiled file exists (named for the original file plus the <strong>.zwc</strong></p>
<p>​    extension) and it is newer than the original file, the compiled file will be used</p>
<p>​    instead.</p>
<p><strong>FILES</strong></p>
<p>​    <strong>$ZDOTDIR&#x2F;.zshenv</strong></p>
<p>​    <strong>$ZDOTDIR&#x2F;.zprofile</strong></p>
<p>​    <strong>$ZDOTDIR&#x2F;.zshrc</strong></p>
<p>​    <strong>$ZDOTDIR&#x2F;.zlogin</strong></p>
<p>​    <strong>$ZDOTDIR&#x2F;.zlogout</strong></p>
<p>​    <strong>${TMPPREFIX}*</strong>  (default is &#x2F;tmp&#x2F;zsh*)</p>
<p>​    <strong>&#x2F;etc&#x2F;zshenv</strong></p>
<p>​    <strong>&#x2F;etc&#x2F;zprofile</strong></p>
<p>​    <strong>&#x2F;etc&#x2F;zshrc</strong></p>
<p>​    <strong>&#x2F;etc&#x2F;zlogin</strong></p>
<p>​    <strong>&#x2F;etc&#x2F;zlogout</strong>  (installation-specific - <strong>&#x2F;etc</strong> is the default)</p>
</blockquote>
<p>zsh使用的是这些配置文件，所以在上面说的两个bash使用的配置文件中添加环境变量，默认是不加载的。</p>
<p>所以</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo export JAVA_HOME=\$\(/usr/libexec/java_home\) &gt;&gt; ~/.zshenv</span><br></pre></td></tr></table></figure>

<p>关于进一步详细设置，可以参考<a href="https://qastack.cn/programming/22842743/how-to-set-java-home-environment-variable-on-mac-os-x-10-9">如何在Mac OS X 10.9上设置JAVA_HOME环境变量？</a></p>
<p>关于zsh的配置文件的比较，可以参考<a href="https://scriptingosx.com/2019/06/moving-to-zsh-part-2-configuration-files/">Moving to zsh, part 2: Configuration Files</a>和<a href="https://chenyufei.info/blog/2014-03-04/zsh-tmux-osx-set-correct-path/">zsh+tmux+OS X: 正确地设置 PATH</a>这两篇博客。</p>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>OS X</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/binary-tree/</url>
    <content><![CDATA[<p>数据结构总结——二叉树</p>
<p>总结常见的二叉树相关的算法以及代码实现</p>
<span id="more"></span>

<p><strong>二叉树定义</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><ul>
<li>递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归方法(同理可得中序遍历和后序遍历的递归方法)</span></span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        preorderTraversal(root.left);</span><br><span class="line">        preorderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>迭代</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        result.add(temp.val);</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        inorderTraversal(root.left);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        inorderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//迭代方法同前序遍历</span></span><br></pre></td></tr></table></figure>



<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        postorderTraversal(root.left);</span><br><span class="line">        postorderTraversal(root.right);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代方法同前序遍历</span></span><br></pre></td></tr></table></figure>

<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS</span></span><br><span class="line">同前序遍历</span><br></pre></td></tr></table></figure>

<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.peek();</span><br><span class="line">            q.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            level.add(cur.val);</span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!level.isEmpty()) &#123;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="计算树的高度"><a href="#计算树的高度" class="headerlink" title="计算树的高度"></a>计算树的高度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftde</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightde</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftde, rightde) +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="计算树的直径"><a href="#计算树的直径" class="headerlink" title="计算树的直径"></a>计算树的直径</h3><ul>
<li><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">leetcode-543</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> result&gt;<span class="number">0</span>?result-<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> depth(node.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> depth(node.right);</span><br><span class="line">    result = Math.max(result,L+R+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(R,L) +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="镜像二叉树"><a href="#镜像二叉树" class="headerlink" title="镜像二叉树"></a>镜像二叉树</h3><ul>
<li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">leetcode</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    mirrorTree(root.left);</span><br><span class="line">    mirrorTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="判断一个树是否镜像"><a href="#判断一个树是否镜像" class="headerlink" title="判断一个树是否镜像"></a>判断一个树是否镜像</h3><ul>
<li><a href="https://leetcode-cn.com/problems/symmetric-tree/">leetcode-101</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root ==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode mleft, TreeNode mright)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mleft ==<span class="literal">null</span>&amp;&amp; mright == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mleft == <span class="literal">null</span> || mright == <span class="literal">null</span> || mleft.val != mright.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compare(mleft.left, mright.right) &amp;&amp; compare(mleft.right, mright.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉搜索树转化为累加树"><a href="#二叉搜索树转化为累加树" class="headerlink" title="二叉搜索树转化为累加树"></a>二叉搜索树转化为累加树</h3><ul>
<li><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">leetcode-538</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        convertBST(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>同一台电脑为Git配置多个SSH Key</title>
    <url>/config-multiple-ssh-keys/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ol>
<li><p>使用同一台电脑向不同的git平台提交代码</p>
</li>
<li><p>使用同一台电脑向同一个git平台的不同账号提交代码</p>
</li>
</ol>
<span id="more"></span>

<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="为多个平台配置SSH-Key"><a href="#为多个平台配置SSH-Key" class="headerlink" title="为多个平台配置SSH Key"></a>为多个平台配置SSH Key</h2><p>以Github和Gitlab两个平台为例，同时为两个平台创建SSH Key</p>
<ol>
<li><p>生成Github的SSH-Key</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&#x27;github_mail@domain.com&#x27;</span> -f ~/.ssh/github_id_rsa</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成Gitlab的SSH-Key</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&#x27;gitlab_mail@domain.com&#x27;</span> -f ~/.ssh/gitlab_id_rsa</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>config</code>文件管理多个Key</p>
<p>在<code>~/.ssh</code>文件夹下新建一个<code>config</code>文件，如果有就直接在末尾追加内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/.ssh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> config</span></span><br></pre></td></tr></table></figure>

<p>在<code>config</code>文件中写入如下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/github_id_rsa</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab</span></span><br><span class="line">Host gitlab.some_url.com</span><br><span class="line">HostName gitlab.some_url.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/gitlab_id_rsa</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ssh命令测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@gitlab.com</span></span><br></pre></td></tr></table></figure>

<p>以GitHub为例，如果连接成功，会有如下返回内容</p>
<p><code>Hi code-ant! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p>
</li>
</ol>
<h2 id="为统一平台多个账户配置SSH-Key"><a href="#为统一平台多个账户配置SSH-Key" class="headerlink" title="为统一平台多个账户配置SSH Key"></a>为统一平台多个账户配置SSH Key</h2><p>还有一些时候，我们在GitHub有多个账号，需要同时给两个账号创建SSH Key.</p>
<p>这种情况下的配置和上面为两个平台配置SSH Key步骤类似，主要区别集中在使用Host区分不同账号上面.</p>
<p>假设此时有两个GitHub账号，一个叫做<code>code-ant</code>，另一个叫做<code>nobodyKnowsMe</code>.</p>
<ol>
<li><p>为<code>code-ant</code>账号创建SSH Key</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&#x27;code-ant@domain.com&#x27;</span> -f ~/.ssh/code_ant_id_rsa</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为<code>nobodyKnowsMe</code>创建SSH Key</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh-keygen -t rsa -C <span class="string">&#x27;nobodyKnowsMe@domain.com&#x27;</span> -f ~/.ssh/nobody_id_rsa</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>config</code>文件管理多个Key</p>
<p>在<code>~/.ssh</code>文件夹下新建一个<code>config</code>文件，如果有就直接在末尾追加内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/.ssh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> config</span></span><br></pre></td></tr></table></figure>

<p>在<code>config</code>文件中写入如下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">code-ant</span></span><br><span class="line">Host code-ant.github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/code_ant_id_rsa</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nobodyKnowsMe</span></span><br><span class="line">Host nobodyKnowsMe.github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/nobody_id_rsa</span><br></pre></td></tr></table></figure>

<p>说明：git会根据<code>config</code>文件中的<code>Host</code>和<code>HostName</code>做替换</p>
</li>
<li><p>使用ssh命令测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@code-ant.github.com</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@nobodyKnowsMe.gitlab.com</span></span><br></pre></td></tr></table></figure>

<p>以<code>code-ant</code>为例，如果连接成功，会有如下返回内容</p>
<p><code>Hi code-ant! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p>
</li>
<li><p>使用git访问不同的账号</p>
<p>使用<code>code-ant</code>账号拉取、提交代码</p>
<p><code>git clone git@code-ant.github.com/code-ant/XXX.git</code></p>
<p>使用<code>nobodyKnowsMe</code>账号拉取提交代码</p>
<p><code>git clone git@nobodyKnowsMe.github.com/nobodyKnowsMe/xxx.git</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>多账号</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用笔记</title>
    <url>/git-notes/</url>
    <content><![CDATA[<p>记录一些常见的git命令吧</p>
<span id="more"></span>

<ul>
<li><p>创建分支</p>
<p><code>git branch branchName</code></p>
</li>
<li><p>切换分支</p>
<p><code>git checkout targetBranch</code></p>
</li>
<li><p>创建分支并切换到该分支</p>
<p><code>git checkout -b branchName</code></p>
</li>
<li><p>拉取远程分支到本地</p>
<p><code>git checkout -b localbranch origin/remoteBranch</code></p>
<p><code>git pull origin master</code></p>
</li>
<li><p>推送本地分支到远程</p>
<p><code>git push origin localBranch</code></p>
</li>
<li><p>删除本地分支</p>
<p><code>git branch -d localBranch</code></p>
</li>
<li><p>删除远程分支</p>
<p><code>git push origin :branchToboDeleted</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下使用Git出现中文乱码</title>
    <url>/git%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p>Windows下使用Git查看git log的时候出现乱码</p>
</blockquote>
<ul>
<li><strong>现象</strong><ul>
<li><code>cmd</code> <code>powershell</code>都是乱码</li>
<li>idea的<code>Terminal</code>终端也显示乱码</li>
<li><code>Git Bash</code>可以正常显示中文</li>
</ul>
</li>
</ul>
<span id="more"></span>

<img src=" http://images.wpt6.cn/20200214-1.jpg" alt="powershell使用Git中文乱码" style="zoom:80%;" />

<img src=" http://images.wpt6.cn/20200214-2.jpg" alt="cmd使用Git中文乱码" style="zoom:80%;" />

<p><img src="http://images.wpt6.cn/20200214-3.jpg" alt="Gitbash显示中文正常"></p>
<ul>
<li><p><strong>解决方法</strong></p>
<ul>
<li><p>方法一：<em>推荐</em></p>
<p>设置一条<code>LESSCHARSET=UTF-8</code>的环境变量–系统变量</p>
<img src=" http://images.wpt6.cn/20200214-4.jpg" alt="设置系统变量" style="zoom:80%;" />

<p>设置完成，重新打开终端使用Git</p>
</li>
<li><p>方法二：</p>
<p>设置一条<code>LESSCHARSET=UTF-8</code>的环境变量–用户变量</p>
<img src=" http://images.wpt6.cn/20200214-5.jpg" alt="设置用户变量" style="zoom:80%;" />

<p><strong>注意：此时在idea中使用还是会出现中文乱码</strong></p>
<ul>
<li>原因：在idea中的<code>cmd</code> <code>powershell</code>只加载了系统变量并没有加载用户变量，需要在idea中重新设置一条<code>LESSCHARSET=UTF-8</code>的配置</li>
</ul>
<p><img src="http://images.wpt6.cn/20200214-6.jpg" alt="idea中添加配置"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>idea</tag>
        <tag>乱码</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】int32 to IPv4</title>
    <url>/int32-to-IPv4/</url>
    <content><![CDATA[<h3 id="【CodeWars】int32-to-IPv4"><a href="#【CodeWars】int32-to-IPv4" class="headerlink" title="【CodeWars】int32 to IPv4"></a>【CodeWars】int32 to IPv4</h3><p>Take the following IPv4 address: <code>128.32.10.1</code></p>
<p>This address has 4 octets where each octet is a single byte (or 8 bits).</p>
<ul>
<li>1st octet <code>128</code> has the binary representation: <code>10000000</code></li>
<li>2nd octet <code>32</code> has the binary representation: <code>00100000</code></li>
<li>3rd octet <code>10</code> has the binary representation: <code>00001010</code></li>
<li>4th octet <code>1</code> has the binary representation: <code>00000001</code></li>
</ul>
<p>So <code>128.32.10.1</code> &#x3D;&#x3D; <code>10000000.00100000.00001010.00000001</code></p>
<p>Because the above IP address has 32 bits, we can represent it as the unsigned 32 bit number: <code>2149583361</code></p>
<p>Complete the function that takes an unsigned 32 bit number and returns a string representation of its IPv4 address.</p>
<span id="more"></span>

<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2149583361 ==&gt; &quot;128.32.10.1&quot;</span><br><span class="line">32         ==&gt; &quot;0.0.0.32&quot;</span><br><span class="line">0          ==&gt; &quot;0.0.0.0&quot;</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>按照题目描述，点分十进制的IP地址转换成点分二进制之后，去掉分隔符后转化成unsigned 32位整数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">128.32.10.1 ---&gt; 10000000.00100000.00001010.00000001 ---&gt; 10000000001000000000101000000001 ---&gt; 2149583361</span><br></pre></td></tr></table></figure>

<p>此题最终思路只需将上述转化过程逆序实现即可。</p>
<p>利用与运算取最后8位二进制：2149583361 &amp; 0xff</p>
<p>利用无符号右移、与运算取倒数第二个8位二进制：2149583361&gt;&gt;&gt;8 &amp; 0xff</p>
<p>同理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kata</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longToIP</span><span class="params">(<span class="type">long</span> ip)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;%d.%d.%d.%d&quot;</span>,ip &gt;&gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>,ip &gt;&gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>,ip &gt;&gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>,ip &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>每日一题</category>
        <category>CodeWars</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>CodeWars</tag>
        <tag>BINARY</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac使用教程</title>
    <url>/mac-use-guide/</url>
    <content><![CDATA[<p>&#x3D;&#x3D;Mac常用功能教程&#x3D;&#x3D;</p>
<span id="more"></span>

<h1 id="开机"><a href="#开机" class="headerlink" title="开机"></a>开机</h1><p>TouchBar右侧按钮</p>
<h1 id="关机、重启、睡眠"><a href="#关机、重启、睡眠" class="headerlink" title="关机、重启、睡眠"></a>关机、重启、睡眠</h1><p>左上角苹果图标</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-34-52.png" alt="image-20220714123451427"></p>
<p>所有需要的操作都在这里</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-35-17.png" alt="image-20220714123516067"></p>
<h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><p>Mac有四种方式安装软件</p>
<ul>
<li><p>从AppStore应用商店安装</p>
<p>点击屏幕下方Docker中的启动台（不同的系统版本这个图标可能不一样，最新系统版本应该是一个九宫格的彩色方块），找到AppStore打开，搜索软件（这里面软件比较少）</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-35-42.png" alt="image-20220714123541993"></p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-33-30.png" alt="image-20220714100559076"></p>
</li>
<li><p>从网站下载安装包安装</p>
<p><em>Mac的软件包常见的有两种，后缀名分别是pkg和dmg</em></p>
<p>下载下来的安装包一般默认在“下载”文件夹里面，有两个地方可以找到</p>
<ol>
<li><p>Docker中，废纸篓左侧的图标，这个展开样式可以通过右键点击切换</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-54-22.png" alt="image-20220714125422358"></p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-13-04-32.png" alt="image-20220714130432301"></p>
</li>
<li><p>在访达中查看下载</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-55-17.png" alt="image-20220714125517049"></p>
</li>
</ol>
<p>dmg安装方法：双击打开下载后的安装包，根据提示，拖动左侧应用图标到右侧图标上面，然后松手即可完成安装，等到安装完成后，在应用列表中可以找到</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-55-39.png" alt="image-20220714125538836"></p>
<p>pkg安装方法：双击打开安装包，根据提示选择路径，按需输入密码完成安装（跟Windows安装相似）</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-33-28.png" alt="image-20220714102327506"></p>
</li>
<li><p>使用homebrew安装</p>
<p>首先安装homebrew，地址在：<a href="https://brew.sh/">https://brew.sh/</a></p>
<p>在网站上点击按钮复制安装命令</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-55-55.png" alt="image-20220714125555347"></p>
<p>从启动台找到“终端”，并 点击打开</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-56-10.png" alt="image-20220714125609941"></p>
<p>使用鼠标右键粘贴，或者按键<code>Command+V</code>粘贴刚才复制的命令，回车执行</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-56-26.png" alt="image-20220714125626543"></p>
<p>等待homebrew安装完成后，输入<code>brew install XXX</code>安装需要的软件，以安装git为例</p>
<p>输入<code>brew install git</code>，等待执行完，git就安装好了，其他软件也可以类似安装。</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-56-42.png" alt="image-20220714125641822"></p>
</li>
<li><p>直接下载编译好的可执行文件</p>
<p>一般会给tar.gz的压缩包，直接在下载里面双击打开压缩包就可以，Mac可以自动解压压缩包到同名文件夹中，可执行文件比较特殊，需要以命令行执行。</p>
<p>如果解压出来是后缀为.app的格式，则可以双击运行。</p>
</li>
</ul>
<h1 id="软件卸载"><a href="#软件卸载" class="headerlink" title="软件卸载"></a>软件卸载</h1><ul>
<li><p>dmg安装的软件，直接在访达中找到应用程序，找到要卸载的应用，移到废纸篓🗑️即可</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-13-10-03.png" alt="image-20220714131002455"></p>
</li>
<li><p>pkg安装的软件</p>
<p>尝试安装app cleaner应用去清理，或者uninstallpkg，使用这两个清理工具</p>
</li>
<li><p>homebrew安装的软件</p>
<p>使用<code>brew uninstall XXX</code>卸载</p>
</li>
</ul>
<h1 id="显示隐藏文件"><a href="#显示隐藏文件" class="headerlink" title="显示隐藏文件"></a>显示隐藏文件</h1><p>在Mac中隐藏文件以英文字符的句号<code>.</code>为开头命名，默认隐藏，需要显示的话</p>
<ol>
<li><p>在访达中显示隐藏文件，同时按下<code>Command+Shift+.</code>显示隐藏文件，再按一下隐藏</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-33-29.png" alt="image-20220714104849028"></p>
</li>
<li><p>在 终端中显示隐藏文件，输入<code>ls -a</code>能够显示出所有的文件，包括隐藏文件</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-57-01.png" alt="image-20220714125701075"></p>
</li>
</ol>
<h1 id="删除文件快捷键"><a href="#删除文件快捷键" class="headerlink" title="删除文件快捷键"></a>删除文件快捷键</h1><p>在访达中删除文件，除了用鼠标以外还可以使用键盘快速操作，选中文件，然后同时按下<code>Command+BackSpace</code>,BackSpace键就是删除字符的按键。</p>
<h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><p>终端的使用和前面学的Centos Linux使用时一样的</p>
<h1 id="多功能键"><a href="#多功能键" class="headerlink" title="多功能键"></a>多功能键</h1><p>Touch Bar默认不会显示多功能键（F1-F12），需要按下键盘左下角的Fn键，然后Touch Bar会显示多功能键。</p>
<h1 id="进入退出全屏"><a href="#进入退出全屏" class="headerlink" title="进入退出全屏"></a>进入退出全屏</h1><p>应用窗口左上角三个点中，绿色的点，点击一下可以进入全屏，鼠标悬停可以有更多分屏选项</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-41-31.png" alt="image-20220714124131223"></p>
<p>退出全屏，在全屏状态下，鼠标放到窗口顶部，悬停1秒，会出现标题栏，再次点击绿色按钮退出全屏</p>
<p><img src="http://images.wpt6.cn/blog/2022-07-14-12-43-31.png" alt="image-20220714124331716"></p>
<h1 id="切换桌面"><a href="#切换桌面" class="headerlink" title="切换桌面"></a>切换桌面</h1><p>Mac中全屏以后，应用窗口会在新的桌面中打开，这个时候如果想切换到其他程序，可以</p>
<ol>
<li>用<code>Command+Tab</code>选中要切换的其他程序</li>
<li>按下<code>control+⤒</code>选择需要的应用窗口或者桌面</li>
<li>按下<code>control+⟵/⟶</code>切换桌面</li>
</ol>
<h1 id="中英文切换、大小写锁定"><a href="#中英文切换、大小写锁定" class="headerlink" title="中英文切换、大小写锁定"></a>中英文切换、大小写锁定</h1><p>Windows键盘中的大写锁定按钮，点按一次切换中英文，长按锁定大写，再次长按取消锁定</p>
<h1 id="调整屏幕亮度"><a href="#调整屏幕亮度" class="headerlink" title="调整屏幕亮度"></a>调整屏幕亮度</h1><p>使用TouchBar调整，点击太阳🌞图标，然后拖动调整。</p>
<h1 id="音量调整"><a href="#音量调整" class="headerlink" title="音量调整"></a>音量调整</h1><p>同亮度调整方法。还可以一键静音</p>
<h1 id="键盘灯亮度调整"><a href="#键盘灯亮度调整" class="headerlink" title="键盘灯亮度调整"></a>键盘灯亮度调整</h1><p>Touch Bar中亮度调整旁边有个向左的箭头❮，点击展开，展开后可以使用按钮调整键盘灯亮度</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】交替打印FooBar</title>
    <url>/printfoobar/</url>
    <content><![CDATA[<blockquote>
<p>继续划水</p>
</blockquote>
<h3 id="【LeetCode】1115-交替打印FooBar"><a href="#【LeetCode】1115-交替打印FooBar" class="headerlink" title="【LeetCode】1115. 交替打印FooBar"></a>【LeetCode】1115. 交替打印FooBar</h3><p>我们提供一个类：</p>
<p>两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。</p>
<p>请设计修改程序，以确保 “foobar” 被输出 n 次。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 1:</p>
<p><code>输入: n = 1</code><br><code>输出: &quot;foobar&quot;</code><br><code>解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，&quot;foobar&quot; 将被输出一次。</code></p>
<p>示例 2:</p>
<p><code>输入: n = 2</code><br><code>输出: &quot;foobarfoobar&quot;</code><br><code>解释: &quot;foobar&quot; 将被输出两次。</code></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FooBar</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;   <span class="comment">// f-foo, t-bar</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">while</span>( flag) wait();</span><br><span class="line">            printFoo.run();</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// printBar.run() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">while</span>( !flag) wait();</span><br><span class="line">            printBar.run();</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis学习笔记</title>
    <url>/mybatis-note/</url>
    <content><![CDATA[<p>记录MyBatis一些问题</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Github、npm配置代理</title>
    <url>/proxy/</url>
    <content><![CDATA[<p>鉴于一些网络环境的问题，有必要收藏一些代理的使用方法。</p>
<p>记录一些代理的配置方法</p>
<span id="more"></span>

<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="Github设置代理"><a href="#Github设置代理" class="headerlink" title="Github设置代理"></a>Github设置代理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局</span></span><br><span class="line">git config --global http.proxy &#x27;socks5://username:password@server:port &#x27;</span><br><span class="line">git config --global https.proxy &#x27;socks5://username:password@server:port &#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">局部</span></span><br><span class="line">git config --local http.proxy username:password@server:port</span><br></pre></td></tr></table></figure>

<h3 id="只对于github-com"><a href="#只对于github-com" class="headerlink" title="只对于github.com"></a>只对于github.com</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<h3 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.https://github.com.proxy</span><br></pre></td></tr></table></figure>

<h3 id="查询是否使用代理："><a href="#查询是否使用代理：" class="headerlink" title="查询是否使用代理："></a>查询是否使用代理：</h3><ul>
<li>查询全局代理</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy</span><br></pre></td></tr></table></figure>

<ul>
<li>查询局部代理</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --local http.proxy</span><br></pre></td></tr></table></figure>

<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="npm设置代理"><a href="#npm设置代理" class="headerlink" title="npm设置代理"></a>npm设置代理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set proxy http://username:password@server:port </span><br><span class="line">npm confit set https-proxy http://username:password@server:port</span><br></pre></td></tr></table></figure>

<h3 id="npm删除代理"><a href="#npm删除代理" class="headerlink" title="npm删除代理"></a>npm删除代理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config delete proxy</span><br><span class="line">npm config delete https-proxy</span><br></pre></td></tr></table></figure>

<h3 id="如果代理不支持https的话需要修改npm存放package的网站地址。"><a href="#如果代理不支持https的话需要修改npm存放package的网站地址。" class="headerlink" title="如果代理不支持https的话需要修改npm存放package的网站地址。"></a>如果代理不支持https的话需要修改npm存放package的网站地址。</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry &quot;http://registry.npmjs.org/&quot;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="npm相关配置"><a href="#npm相关配置" class="headerlink" title="npm相关配置"></a>npm相关配置</h3><blockquote>
<p>npm获取配置有6种方式，优先级由高到底。</p>
<ol>
<li>命令行参数。 <code>--proxy http://server:port</code>即将proxy的值设为<code>http://server:port</code>。</li>
<li>环境变量。 以<code>npm_config_</code>为前缀的环境变量将会被认为是npm的配置属性。如设置proxy可以加入这样的环境变量<code>npm_config_proxy=http://server:port</code>。</li>
<li>用户配置文件。可以通过<code>npm config get userconfig</code>查看文件路径。如果是mac系统的话默认路径就是<code>$HOME/.npmrc</code>。</li>
<li>全局配置文件。可以通过<code>npm config get globalconfig</code>查看文件路径。mac系统的默认路径是<code>/usr/local/etc/npmrc</code>。</li>
<li>内置配置文件。安装npm的目录下的npmrc文件。</li>
<li>默认配置。 npm本身有默认配置参数，如果以上5条都没设置，则npm会使用默认配置参数。</li>
</ol>
<p>针对npm配置的命令行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set &lt;key&gt; &lt;value&gt; [--global]</span><br><span class="line">npm config get &lt;key&gt;</span><br><span class="line">npm config delete &lt;key&gt;</span><br><span class="line">npm config list</span><br><span class="line">npm config edit</span><br><span class="line">npm get &lt;key&gt;</span><br><span class="line">npm set &lt;key&gt; &lt;value&gt; [--global]</span><br></pre></td></tr></table></figure>

<p>在设置配置属性时属性值默认是被存储于用户配置文件中，如果加上<code>--global</code>，则被存储在全局配置文件中。</p>
<p>如果要查看npm的所有配置属性（包括默认配置），可以使用<code>npm config ls -l</code>。</p>
<p>如果要查看npm的各种配置的含义，可以使用<code>npm help config</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>git</tag>
        <tag>github</tag>
        <tag>代理</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-随笔</title>
    <url>/redis-%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<ul>
<li><p>Redis的基本数据类型</p>
<span id="more"></span>

<ul>
<li><p>String</p>
<ul>
<li><p>基本操作</p>
<p>SET——设置</p>
<p>GET——获取值</p>
<p>EXISTS——是否存在</p>
<p>DEL——删除</p>
<p>EXPIRE——设置过期，EXPIRE KEY SEC</p>
<p>SETNX——SET+EXPIRE</p>
<p>MSET——批量设置，MSET key1 value1 key2 value2</p>
<p>MGET——批量获取，MGET key1 key2 key3</p>
<p>INCR——对整数值原子性自增操作</p>
<p>GETSET——设置一个值并返回原值</p>
</li>
</ul>
</li>
<li><p>list</p>
<ul>
<li><p>基本操作</p>
<p>LPUSH&#x2F;RPUSH——向左右添加一个元素</p>
<p>LRANGE——从LIST中取出一定范围的元素</p>
<p>LINDEX——从list中取出制定下标的元素</p>
<p>LPOP&#x2F;RPOP——从左右节点弹出一个元素</p>
</li>
</ul>
</li>
<li><p>hash</p>
<ul>
<li><p>基本操作</p>
<p>HSET——设置hash</p>
<p>HGETALL——获取全部元素</p>
<p>HGET——获取指定key的值</p>
<p>HMSET——批量设置</p>
</li>
<li><p>渐进式rehash，节省时间</p>
</li>
<li><p>扩容按照2倍进行扩容，如果在做持久化则尽量不去做扩容。达到一维数组长度5倍的时候会强制扩容。</p>
</li>
</ul>
</li>
<li><p>set</p>
<ul>
<li><p>内部键值对是无序的、唯一的</p>
</li>
<li><p>基本使用</p>
<p>SADD创建</p>
<p>SMEMBERS——读取所有元素</p>
<p>SISMEMBER——查询是否存在</p>
<p>SCARD——查询长度</p>
<p>SPOP—— 弹出一个</p>
</li>
</ul>
</li>
<li><p>zset-有序集合</p>
<ul>
<li><p>内部使用跳跃表实现</p>
</li>
<li><p>基本操作</p>
<p>ZRANGE——按照顺序排列</p>
<p>ZREVRANGE——按照逆序输出</p>
<p>ZCARD——统计长度</p>
<p>ZSCORE——获取指定value的score</p>
<p>ZRANK——获取排名</p>
<p>ZRANGEBYSCORE——遍历指定区间的元素</p>
<p>ZREM——删除一个value</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>String的实现–简单动态字符串，SDS(Simple Dynamic String)</p>
</li>
<li><p>SDS和C语言字符串的区别</p>
<ul>
<li><p>计数方式不一样</p>
<ul>
<li><p>C语言O(n)，发现<code>‘\0</code>’停止计数</p>
</li>
<li><p>SDS的数据结构已经保存了字符串长度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line"> <span class="type">int</span> len;</span><br><span class="line"> <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"> <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>杜绝缓冲区溢出</p>
<ul>
<li>通过<code>free</code>判断是否需要扩容</li>
</ul>
</li>
<li><p>减少修改字符串时的内存重新分配</p>
<ul>
<li>空间预分配</li>
<li>惰性空间释放</li>
</ul>
</li>
<li><p>二进制安全</p>
</li>
</ul>
</li>
</ul>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表的实现比较复杂，也是一个重点，需要刻意关注。</p>
<ul>
<li><p>为什么使用跳跃表</p>
<p>zset需要支持随机插入和删除，所以不宜使用数组来实现。相比于红黑树&#x2F;平衡树，跳跃表的优势在于<strong>性能</strong>和<strong>实现</strong>。</p>
<p><strong>性能</strong>：高并发的情况下，树的rebalance可能涉及整个树。跳跃表只会涉及到局部。</p>
<p><strong>实现</strong>：在复杂度与红黑树相同的情况下，跳跃表实现起来更加简单，更直观。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/sort-algo/</url>
    <content><![CDATA[<p>总结十大经典排序算法，分析稳定性、时间复杂度等内容；</p>
<h3 id="算法相关定义"><a href="#算法相关定义" class="headerlink" title="算法相关定义"></a>算法相关定义</h3><ul>
<li><p>时间复杂度：</p>
<p>在 大O符号表示法中，时间复杂度的公式是： T(n) &#x3D; O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：<strong>算法的渐进时间复杂度</strong>。</p>
<p>常见的时间复杂度量级有：</p>
<span id="more"></span>

<ul>
<li>常数阶O(1)</li>
</ul>
<!--添加时间复杂度的详细计算方法-->

<ul>
<li>对数阶O(logN)</li>
<li>线性阶O(n)</li>
<li>线性对数阶O(nlogN)</li>
<li>平方阶O(n²)</li>
<li>立方阶O(n³)</li>
<li>K次方阶O(n^k)</li>
<li>指数阶(2^n)</li>
</ul>
</li>
<li><p>空间复杂度：</p>
<p>既然时间复杂度不是用来计算程序具体耗时的，那么也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，用 S(n) 来定义。</p>
<p>空间复杂度比较常用的有：O(1)、O(n)、O(n²)</p>
</li>
<li><p>内排序和外排序</p>
<p>根据排序元素所在位置的不同,排序分: 内排序和外排序。</p>
<ul>
<li><p>内排序：指在排序期间数据对象全部存放在内存的排序。</p>
</li>
<li><p>外排序：指在排序期间全部对象太多，不能同时存放在内存中，必须根据排序过程的要求，不断在内，外存间移动的排序。</p>
</li>
</ul>
<p>内排序在排序过程中，所有元素调到内存中进行的排序，内排序是排序的基础。内排序效率用比较次数来衡量。按所用策略不同，内排序又可分为插入排序、选择排序、交换排序、归并排序及基数排序等几大类。在数据量大的情况下，只能分块排序，但块与块间不能保证有序。外排序用读&#x2F;写外存的次数来衡量其效率。</p>
</li>
<li><p>排序算法的稳定性</p>
<p>  假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，**r<sub>i</sub>&#x3D;r<sub>j</sub><strong>，且</strong>r<sub>i</sub><strong>在</strong>r<sub>j</sub><strong>之前，而在排序后的序列中，</strong>r<sub>i</sub><strong>仍在</strong>r<sub>j</sub>**之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
</li>
</ul>
<h3 id="十大经典排序算法对比"><a href="#十大经典排序算法对比" class="headerlink" title="十大经典排序算法对比"></a>十大经典排序算法对比</h3><p><img src="http://images.wpt6.cn/blog/2020-09-01-00-39-16.jpg"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
<li>内排序：Y</li>
</ul>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSorted</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; array.length-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j]&lt;array[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[j];</span><br><span class="line">                array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">                array[j-<span class="number">1</span>]= temp;</span><br><span class="line">                isSorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ul>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
<li>内排序：Y</li>
</ul>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[min];</span><br><span class="line">        array[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
<li>内排序：Y</li>
</ul>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">            array[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
<li>内排序：Y</li>
</ul>
<h5 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h5><p>选择一个增量序列 t<sub>1</sub>，t<sub>2</sub>，……，t<sub>k</sub>，其中 t<sub>i</sub> &gt; t<sub>j</sub>, t<sub>k</sub> &#x3D; 1；</p>
<p>按增量序列个数 k，对序列进行 k 趟排序；</p>
<p>每趟排序，根据对应的增量 t<sub>i</sub>，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; array.length) &#123;</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(gap);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; temp) &#123;</span><br><span class="line">                array[j + gap] = array[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap = (<span class="type">int</span>) Math.floor(gap / <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(n)</li>
<li>稳定性：稳定</li>
<li>内排序：N</li>
</ul>
<p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<p>递归和迭代相比较，特定场景下，递归方法可能不适用；例如在JavaScript中递归的算法深度会比较深，是语言所不能承受的。递归方法会导致很频繁的自调用。一个长度为n的数组最终会调用mergeSort() <code>2*n-1</code>次，这意味着如果需要排序的数组长度很大会在某些栈小的浏览器上发生栈溢出错误。尽管迭代的归并排序算法比递归实现要慢一些，但它并不会像递归那样受调用栈限制的影响。把递归算法改用迭代实现是实现栈溢出错误的方法之一</p>
<h5 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h5><ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<p><img src="http://images.wpt6.cn/blog/2020-09-01-22-40-46.jpg"></p>
<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">    sort(<span class="number">0</span>, array.length - <span class="number">1</span>, array, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] array, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        sort(left, mid, array, temp);</span><br><span class="line">        sort(mid + <span class="number">1</span>, right, array, temp);</span><br><span class="line">        merge(left, mid, right, array, temp);</span><br><span class="line">        System.out.println(Arrays.toString(temp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] array, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]&lt;=array[j])&#123;</span><br><span class="line">            temp[t] = array[i];</span><br><span class="line">            t++;i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            temp[t] = array[j];</span><br><span class="line">            t++;j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid)&#123;</span><br><span class="line">        temp[t++] = array[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=right)&#123;</span><br><span class="line">        temp[t++] = array[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        array[left++] = temp[t++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(logn)</li>
<li>稳定性：不稳定</li>
<li>内排序：Y</li>
</ul>
<blockquote>
<p><em>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平均期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</em></p>
</blockquote>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis性能优化</title>
    <url>/redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>Redis在高并发场景下对于性能要求较高，总结一下常用的Redis性能调优方案。</p>
<span id="more"></span>

<h3 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h3><ol>
<li>缩短键值对的存储长度</li>
<li>使用lazy free（延迟删除）特性</li>
<li>设置键值的过期时间</li>
<li>禁用长耗时的查询命令</li>
<li>使用slowlog优化耗时命令</li>
<li>使用pipline批量操作数据</li>
<li>避免大量数据同时失效</li>
<li>客户端使用优化</li>
<li>限制redis内存大小</li>
<li>使用物理机而非虚拟机安装Redis服务</li>
<li>检查数据持久化策略</li>
<li>禁用THP特性</li>
<li>使用分布式架构增加读写速度</li>
</ol>
<h3 id="优化方案解析"><a href="#优化方案解析" class="headerlink" title="优化方案解析"></a>优化方案解析</h3><h4 id="1-缩短键值对的存储产长度"><a href="#1-缩短键值对的存储产长度" class="headerlink" title="1.缩短键值对的存储产长度"></a>1.缩短键值对的存储产长度</h4><p>Redis对于同一种数据类型会使用不同的内部编码进行存储，通过不同编码实现效率和空间的平衡，然而数据量越大，使用的内部编码就会越复杂，越是复杂的内部编码，存储的性能就会越低。</p>
<p>当键值对较大时，还会带来另外的问题：</p>
<ul>
<li>内容越大，需要持久化的时间就会越长，需要挂起的时间越长，Redis的性能越低。</li>
<li>内容越大，网络上传输的内容越多，传输时间变长，整体运行速度降低。</li>
<li>内容大，内存占用变大，会频繁触发内存淘汰机制，给Redis带来更多的运行负担。</li>
</ul>
<p>所以，在保证完整语义的情况下，尽量缩短键值对的存储长度，必要时对数据进行序列化和压缩，然后在存储。</p>
<h4 id="2-使用lazy-free特性"><a href="#2-使用lazy-free特性" class="headerlink" title="2.使用lazy free特性"></a>2.使用lazy free特性</h4><p>lazy free是Redis 4.0新增的功能，意思为惰性删除、延迟删除，在删除的时候提供异步延时释放键值的功能，把键值释放操作放在BIO（Background I&#x2F;O）单独的子线程中处理，减少删除对主线程的阻塞，可以有效避免删除big key时带来的性能和可用性问题。</p>
<p>四种场景：</p>
<ul>
<li>lazyfree-lazy-eviction：当Redis运行内存超过maxmemory时，是否开启lazy free机制删除。</li>
<li>lazyfree-lazy-expire：表示设置了过期时间的键值，过期之后是否开启lazy free机制删除。</li>
<li>lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个隐式的del键操作，例如rename命令，当目标键已经存在，Redis会先删除目标键，如果这些目标键是big key就会造成阻塞删除的问题。</li>
<li>lazyfree-lazy-flush：针对 slave 从节点进行全量数据同步，slave在加载 master 的RDB文件前，会会运行flushall来清理自己的数据。</li>
</ul>
<h4 id="3-设置键值的过期时间"><a href="#3-设置键值的过期时间" class="headerlink" title="3.设置键值的过期时间"></a>3.设置键值的过期时间</h4><p>根据实际业务情况，设置键值的合理过期时间，Redis会自动清除过期的键值对，节约内存占用，避免键值对过多的堆积，频发触发淘汰策略。</p>
<h4 id="4-禁用长耗时的查询命令"><a href="#4-禁用长耗时的查询命令" class="headerlink" title="4.禁用长耗时的查询命令"></a>4.禁用长耗时的查询命令</h4><p>Redis只用一个线程来做数据查询，如果查询指令时间比较长，就会阻塞Redis，造成延时。</p>
<p>避免O(n)命令对于Redis造成影响，可以有的优化方式:</p>
<ul>
<li>禁止使用keys命令</li>
<li>避免一次查询所有成员，使用scan命令进行分批的、游标式的遍历</li>
<li>通过机制严格控制Hash、Set、Sorted Set等数据结构的大小</li>
<li>将排序、并集、交集等操作放在客户端执行，减少Redis服务器压力</li>
<li>删除一个大数据的时候，可能会需要较长时间，建议用异步删除的方式unlink，会启动一个新的线程来删除目标数据，不阻塞主线程</li>
</ul>
<h4 id="5-使用slowlog优化查询耗时"><a href="#5-使用slowlog优化查询耗时" class="headerlink" title="5.使用slowlog优化查询耗时"></a>5.使用slowlog优化查询耗时</h4><p>使用slowlog功能找出最耗时的Redis命令进行优化，提高运行速度。</p>
<ul>
<li><code>slowlog-log-slower-than</code>：用于设置慢查询的评定时间，超过此配置项的命令，会被当成慢操作记录在慢查询日志中，执行单位为微妙。</li>
<li><code>slowlog-max-len</code>：配置慢查询日志的最大记录数</li>
</ul>
<h4 id="6-使用pipline批量操作数据"><a href="#6-使用pipline批量操作数据" class="headerlink" title="6.使用pipline批量操作数据"></a>6.使用pipline批量操作数据</h4><p>Pipline-管道技术是客户端提供的一种批处理技术，用于一次处理多个Redis命令，从而提高整个交互的性能。</p>
<h4 id="7-避免大量数据同时失效"><a href="#7-避免大量数据同时失效" class="headerlink" title="7.避免大量数据同时失效"></a>7.避免大量数据同时失效</h4><p>Redis过期键值删除使用的是贪心策略，每秒会进行十次过期扫描，这个扫描频率可以在redia.conf中进程配置，默认值是<code>hz 10</code>，Redis会随机抽取20个值，删除这20个键中过期的键，如果过去key的比例超过25%，会重复执行扫描-选取-删除的过程。</p>
<p>如果在大型系统中有大量缓存在同一时间同时过期，那么Redis会循环多次进行扫描删除操作，直到过期键值被删除的比较稀疏位置，整个删除过程中会导致Redis的读写产生明显卡顿，同时卡顿的另一种原是内存页管理器会频繁回收内存页，因此也会消耗一定的CPU。</p>
<p>为了避免卡顿现象的发生，设计过程中需要预防大量的缓存在同一时刻一起过期，最简单的设计方案就是在过期时间的基础上添加一个指定范围的随机数。</p>
<h4 id="8-客户端使用优化"><a href="#8-客户端使用优化" class="headerlink" title="8.客户端使用优化"></a>8.客户端使用优化</h4><p>在客户端使用时除了尽量使用Pipline以外，还要注意使用Redis连接池，而不是频繁创建销毁Redis连接，这样可以减少网络传输次数和非必要调用指令。</p>
<h4 id="9-限制Redis内存大小"><a href="#9-限制Redis内存大小" class="headerlink" title="9.限制Redis内存大小"></a>9.限制Redis内存大小</h4><p>64位操作系统没有限制Redis的内存大小，配置项<code>maxmemory&lt;bytes&gt;</code>是被注释掉的，这样就会导致在物理内存不足时，使用swap交换空间，操作系统将Redis使用的内存分页迁移到swap的时候，会阻塞Redis进程，Redis会出现延迟，影响整体性能。因此需要设置一个固定的Redis内存大小，当Redis的运行内存达到这个值的时候会触发内存淘汰策略。</p>
<p>Redis 4.0以后内存淘汰策略有8种：</p>
<ol>
<li><code>noeviction</code>：不淘汰任何数据，内存不足时，新增操作会报错，这个是默认的淘汰策略。</li>
<li><code>allkeys-lru</code>：淘汰所有键值中最久未使用的键值</li>
<li><code>allkeys-random</code>：随机淘汰任意键值</li>
<li><code>volatile-lru</code>：淘汰所有设置了过期时间的键值中最久未使用的键值</li>
<li><code>volatile-random</code>：随机淘汰设置了过期时间的任意键值</li>
<li><code>volatile-ttl</code>：优先淘汰更早过期的键值</li>
<li><code>volatile-lfu</code>：淘汰所有设置过期时间的键值中，最少使用的键值</li>
<li><code>allkeys-lfu</code>：淘汰所有键值中使用最少的键值</li>
</ol>
<h4 id="10-使用物理机而非虚拟机"><a href="#10-使用物理机而非虚拟机" class="headerlink" title="10.使用物理机而非虚拟机"></a>10.使用物理机而非虚拟机</h4><h4 id="11-检查数据持久化策略"><a href="#11-检查数据持久化策略" class="headerlink" title="11.检查数据持久化策略"></a>11.检查数据持久化策略</h4><p>Redis的持久化策略是将内存数据复制到硬盘上，这样才能进行容灾恢复或者数据迁移，但是维护持久化的功能，需要很大的性能开销。</p>
<p>持久化方式：</p>
<ul>
<li>RDB（Redis Database，快照方式）将某一个时刻的内存数据以二进制的方式写入磁盘。</li>
<li>AOF（Append Only File，文件追加方式）记录所有的操作命令，并以文本的形式追加到文件中。</li>
<li>混合持久化方式，Redis 4.0以后版本支持。写入的时候，先把当前的数据以RDB的形式写入文件的开头，再将后续的操作命令以AOF的格式写入文件，既能保证Redis重启时的速度，又能降低数据丢失的风险。</li>
</ul>
<p>RDB可能会导致一定时间内的数据丢失，AOF文件较大的话则会影响Redis启动速度，混合持久化方式则结合了两种方式的优点。</p>
<h4 id="12-禁用THP特性"><a href="#12-禁用THP特性" class="headerlink" title="12.禁用THP特性"></a>12.禁用THP特性</h4><p>Linux kernel在 2.6.38内核增加了Transparent Huge Pages（THP）特性，支持大内存页2MB分配。</p>
<p>开启THP的时候，fork速度会变慢，fork之后，每个内存页从4KB变成2MB，会大幅增加重写期间父进程内存消耗。每次写命令引起的复制内存页单位放大了512倍，会拖慢写操作的执行时间，导致大量写操作慢查询。</p>
<h4 id="13-使用分布式架构增加读写速度"><a href="#13-使用分布式架构增加读写速度" class="headerlink" title="13.使用分布式架构增加读写速度"></a>13.使用分布式架构增加读写速度</h4><p>Redis分布式架构的三个重要手段：</p>
<ul>
<li>主从同步</li>
<li>哨兵模式</li>
<li>Redis Cluster集群</li>
</ul>
<p>主从同步把写操作放到主库上执行，读操作放到从服务上，从而在单位时间内处理更多请求，提升性能</p>
<p>哨兵模式主要针对主从功能的升级，当主节点崩溃以后，无需人工干预，能够自动恢复Redis的使用</p>
<p>Redis Cluster集群通过将数据库分散存储到多个节点，平衡各个节点的负载压力。</p>
<blockquote>
<p>Redis Cluster 采用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：slot &#x3D; CRC16(key) &amp; 16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。这样 Redis 就可以把读写压力从一台服务器，分散给多台服务器了，因此性能会有很大的提升。</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>优化</tag>
        <tag>调优</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>常见设计模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li><p>单例模式相关概念</p>
<span id="more"></span>

<ul>
<li>确保一个类最大只有一个实例，提供全局唯一一个访问点。</li>
<li>懒汉式单例模式，加载时不初始化，获取调用时初始化。</li>
<li>饿汉式单例模式，加载时完成初始化，类加载比较慢，获取对象的速度快。</li>
</ul>
</li>
</ul>
<h4 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h4><ul>
<li><p>线程安全</p>
</li>
<li><p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi~~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Singleton.getInstance().sayHi();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="双检锁单例模式"><a href="#双检锁单例模式" class="headerlink" title="双检锁单例模式"></a>双检锁单例模式</h4><ul>
<li><p>线程安全</p>
</li>
<li><p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi~~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Singleton.getInstance().sayHi();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h4><ul>
<li><p>线程安全</p>
</li>
<li><p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi~~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><ul>
<li><p>线程安全</p>
</li>
<li><p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi~~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用评价：花里胡哨，不实用，没达到lazyloading的目的，写法花哨，不推荐</strong></p>
</li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul>
<li><p>定义：给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用。</p>
</li>
<li><p>优势：在不改变目标对象方法的情况下对方法增强。</p>
</li>
<li><p>实现</p>
<p>创建一个用户接口（UserInterface）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对应的用户实现类（UserImpl）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserImpl</span> <span class="keyword">implements</span> <span class="title class_">UserInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;am &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建代理类对象（UserProxy），通过代理类创建实现类的实例，并提供访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> <span class="keyword">implements</span> <span class="title class_">UserInterface</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserInterface user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserProxy</span><span class="params">(UserInterface user)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;check identity&quot;</span>);</span><br><span class="line">        user.service(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;check in&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用时通过proxy调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserImpl</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserImpl</span>();</span><br><span class="line">        <span class="type">UserProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserProxy</span>(user);</span><br><span class="line">        proxy.service(<span class="string">&quot;wpt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><ul>
<li><p>定义：对象之间的一对多依赖，当一个状态改变时，它的所有依赖着都会收到通知并自动更新。Subject时被观察的对象，而其所有依赖者Observer被称为观察者。</p>
</li>
<li><p>原则：为了交互对象之间的松耦合设计，两个对象松耦合，但是可以交互，并不清楚彼此的细节。松耦合的两个对象之间，相互依赖程度低，系统具有弹性，能够应对变化。</p>
</li>
<li><p>实例</p>
<p>被观察者Subject接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察者接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被观察者实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; list;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteSubject</span><span class="params">()</span> &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        list.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!list.isEmpty())&#123;</span><br><span class="line">            list.remove(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer :</span><br><span class="line">                list) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.message = s;</span><br><span class="line">        System.out.println(<span class="string">&quot;update message: &quot;</span>+s);</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义观察者类，实现具体方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteObserver</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; get message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试添加和移除观察者前后收到信息通知的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="type">Observer</span> <span class="variable">observer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="type">Observer</span> <span class="variable">observer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        subject.registerObserver(observer);</span><br><span class="line">        subject.registerObserver(observer1);</span><br><span class="line">        subject.registerObserver(observer2);</span><br><span class="line">        subject.send(<span class="string">&quot;hello, i am here&quot;</span>);</span><br><span class="line"></span><br><span class="line">        subject.removeObserver(observer);</span><br><span class="line">        subject.send(<span class="string">&quot;byebye&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul>
<li>优点：<ul>
<li>将创建实例的工作与使用实例的工作分开，使用者无需关心类对象是如何创建的，明确职责。</li>
<li>初始化实例的工作放在工厂类里面进行，代码容易维护，更符合面向对象的原则，面向接口编程，而不是面向实现编程。</li>
</ul>
</li>
<li>缺点：<ul>
<li>工厂类里面包含了所有的产品创建逻辑，如果出现异常，整个系统都会受影响。</li>
<li>新增产品类的时候就要修改工厂类的代码，与开闭原则不符。</li>
<li>简单工厂模式中使用了静态工厂方法，导致工厂角色无法形成基于继承的等级结构。</li>
</ul>
</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul>
<li><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到子类。</p>
</li>
<li><p>优点</p>
<ul>
<li>更符合开闭原则，新增一种产品，只需要添加相应的具体产品类和对应的工厂子类。</li>
<li>符合单一职责原则，每个具体的工厂类，只负责创建对应的产品</li>
<li>不使用静态工厂方法，可以形成基于继承的等级结构。</li>
</ul>
</li>
<li><p>缺点</p>
<p>添加新的产品的时候，除了增加新产品类以外，还要提供具体的与之对应的工厂类，系统中类的个数成对增加，在一定程度上增加了系统的复杂性，同时更多的类需要编译和运行，增加额外开销。</p>
<p>虽然保证了工厂方法内的对修改关闭，但是对于使用工厂方法的类，如果要更换另一种产品，仍需要修改实例化的具体工厂类。</p>
<p>一个工厂只能创建一种具体产品。</p>
</li>
</ul>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><ul>
<li>提供一个接口，用于创建相关或者依赖对象的家族，不需要明确指定具体类。</li>
<li>优点<ul>
<li>抽象工厂模式隔离了具体类的生产，客户端无需知道具体内容的创建。</li>
<li>一个产品族中的多个对象被设计成一起工作，能保证客户端始终使用同一个产品族中的对象。</li>
<li>增加新的具体工厂和产品族很方便，无需修改已有系统，符合开闭原则。</li>
</ul>
</li>
<li>缺点<ul>
<li>增加新产品的等级结构复杂，需要修改抽象工厂和所有的具体工厂类，对开闭原则的支持呈现倾斜性。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>程序员的修炼</tag>
      </tags>
  </entry>
  <entry>
    <title>使用命令行打开Ubuntu的护眼模式（Night Light）</title>
    <url>/turnon-nightlight/</url>
    <content><![CDATA[<blockquote>
<p>使用命令行打开Ubuntu的Night Mode</p>
</blockquote>
<ul>
<li><p>Ubuntu上的护眼模式（Night Light）</p>
<p>Ubuntu的护眼模式很香，但是不是很好用，如果使用图形界面需要在设置中打开，对于懒癌晚期的患者不是很友好</p>
<span id="more"></span>
</li>
<li><p>解决方法</p>
<ul>
<li><p>终端中用命令打开</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开</span></span><br><span class="line">gsettings set org.gnome.settings-daemon.plugins.color night-light-enabled true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭</span></span><br><span class="line">gsettings set org.gnome.settings-daemon.plugins.color night-light-enabled false</span><br></pre></td></tr></table></figure>

<p>用了两分钟，体验极差，记不住，太长了，需要继续优化</p>
</li>
<li><p>优化方案</p>
<p>想到了<code>alias</code>，可以通过<code>alias</code>别名优化</p>
<ul>
<li>bash的<code>alias</code>不支持参数，需要用到function</li>
</ul>
<p><strong>大致思路</strong></p>
<p>将<code>alias</code>的内容定义成一个函数，由函数处理参数，然后调用函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function nightMode() &#123;</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nightMode &lt;<span class="literal">true</span>|<span class="literal">false</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最终实现</p>
<p>在当前用户的<code>home</code>目录下修改<code>.bashrc</code>文件，末尾追加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">turnon or turnoff nightlight</span></span><br><span class="line">alias nightmode=&#x27;nightmode() &#123; gsettings set org.gnome.settings-daemon.plugins.color night-light-enabled $1;&#125;; nightmode&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用方法</p>
<p>当前用户任意位置打开终端输入<code>nightmode true</code>或者<code>nightmode false</code>打开或者关闭护眼模式</p>
</li>
</ul>
</li>
<li><p>END</p>
</li>
</ul>
]]></content>
      <categories>
        <category>奇淫技巧</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>CLI</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁与悲观锁</title>
    <url>/%E9%94%81/</url>
    <content><![CDATA[<h3 id="什么是乐观锁与悲观锁"><a href="#什么是乐观锁与悲观锁" class="headerlink" title="什么是乐观锁与悲观锁"></a>什么是乐观锁与悲观锁</h3><blockquote>
<p>乐观锁和悲观锁、见名知意，乐观锁设计的出发点是程序总是能够按照正确的，没有异常的情况发展；悲观锁的设计出发点是程序运行时总是会遇到异常。</p>
</blockquote>
<span id="more"></span>

<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞，直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>锁</tag>
      </tags>
  </entry>
</search>
